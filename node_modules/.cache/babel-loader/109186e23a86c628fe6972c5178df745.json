{"ast":null,"code":"var _toConsumableArray = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _objectWithoutProperties = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _inherits = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\athya\\\\Downloads\\\\pcb sudeep\\\\Propcb-frontend-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n// c-promise2 v0.13.12\n// Copyright (c) 2020-2022 Dmitriy Mozgovoy <robotshara@gmail.com>\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.CPromise = factory());\n})(this, function () {\n  'use strict';\n\n  var _Object$definePropert, _Object$definePropert3;\n\n  var version$2 = '0.13.12';\n\n  var _version$2 = Symbol.for('CPromise:version');\n\n  var _versionNumber$2 = Symbol.for('CPromise:version:number');\n\n  var versionNumber$2 = version$2.split('.').reverse().reduce(function (computed, part, i) {\n    return computed + part * Math.pow(1000, i);\n  }, 0);\n  var warned = false;\n\n  var warnVersionInteraction$2 = function warnVersionInteraction$2(thing) {\n    if (!warned) {\n      warned = true;\n      var meta = thing.constructor[_version$2];\n      var versions = \"v\".concat(version$2, \" <=> \").concat(meta ? 'v' + meta.version : '<version older than v0.11.11>');\n      console.warn(\"Interaction of multiple versions of CPromise detected (\".concat(versions, \").\\n      Please update your dependencies to the latest version and avoid using multiple package versions at the same time\"));\n    }\n\n    return thing;\n  };\n\n  var env = {\n    version: version$2,\n    _version: _version$2,\n    versionNumber: versionNumber$2,\n    _versionNumber: _versionNumber$2,\n    warnVersionInteraction: warnVersionInteraction$2\n  };\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n  var hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\n  var isThenable$1 = function isThenable$1(obj) {\n    return !!obj && (typeof obj === 'function' || typeof obj === 'object') && typeof obj.then === 'function';\n  };\n\n  var _setImmediate = typeof setImmediate === 'function' ? setImmediate : function setImmediateShim(cb) {\n    setTimeout(cb, 0);\n  };\n\n  var toStringTag$2 = Symbol.toStringTag;\n\n  var getTag$2 = function getTag$2(thing) {\n    return thing && thing[toStringTag$2] || '';\n  };\n\n  function isGeneratorFunction$1(thing) {\n    return typeof thing === 'function' && thing.constructor && getTag$2(thing) === 'GeneratorFunction';\n  }\n\n  var getFnType$1 = function getFnType$1(thing) {\n    return typeof thing === 'function' && ({\n      GeneratorFunction: 'generator',\n      AsyncFunction: 'async'\n    }[getTag$2(thing)] || 'plain');\n  };\n\n  function isGenerator$1(thing) {\n    return thing && typeof thing === 'object' && typeof thing.next === 'function';\n  }\n\n  function EmptyObject$1() {}\n\n  EmptyObject$1.prototype = null;\n\n  var toGenerator$1 = function toGenerator$1(thing, args) {\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (isGeneratorFunction$1(thing)) {\n      return thing.apply(context, args);\n    }\n\n    return thing && (isGenerator$1(thing) ? thing : thing[Symbol.iterator] && thing[Symbol.iterator]()) || null;\n  };\n\n  var toArray$1 = function toArray$1(thing, mapper) {\n    if (thing) {\n      if (Array.isArray(thing)) {\n        return mapper ? thing.map(mapper) : thing;\n      }\n\n      if (thing = toGenerator$1(thing)) {\n        var arr = [];\n        var item;\n\n        while ((item = thing.next()) && item.done === false) {\n          arr.push(mapper ? mapper(item.value) : item.value);\n        }\n\n        return arr;\n      }\n    }\n\n    return null;\n  };\n\n  var isPropertyDescriptor$1 = function (allowed) {\n    return function (thing) {\n      if (thing !== null && typeof thing === 'object') {\n        var props = Object.getOwnPropertyNames(thing);\n        return props.length && props.every(function (prop) {\n          return allowed[prop];\n        });\n      }\n\n      return false;\n    };\n  }({\n    value: true,\n    set: true,\n    get: true,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n\n  var lazyBindMethods$1 = function lazyBindMethods$1(obj, props) {\n    props.forEach(function (prop) {\n      var symbol = Symbol(\"\".concat(prop, \"Bound\"));\n\n      var _Object$getOwnPropert = Object.getOwnPropertyDescriptor(obj, prop),\n          fn = _Object$getOwnPropert.value;\n\n      Object.defineProperty(obj, prop, {\n        get: function get() {\n          return hasOwnProperty$2.call(this, symbol) ? this[symbol] : this[symbol] = fn.bind(this);\n        },\n        set: function set(v) {\n          throw Error(\"Can not rewrite method \".concat(prop, \" with \").concat(v));\n        },\n        enumerable: true,\n        configurable: true\n      });\n    });\n  };\n\n  var globalObject$1 = function () {\n    if (typeof globalThis !== 'undefined') {\n      return globalThis;\n    }\n\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof commonjsGlobal !== 'undefined') {\n      return commonjsGlobal;\n    }\n  }();\n\n  var isContextDefined$2 = function isContextDefined$2(context) {\n    return context != null && context !== globalObject$1;\n  };\n\n  var throttle$1 = function throttle$1(fn, ms) {\n    var timer = null;\n    var last = null;\n\n    var cancel = function cancel() {\n      if (!timer) return;\n      clearTimeout(timer);\n      timer = null;\n    };\n\n    var wrapper = function wrapper(args, force) {\n      var _this = this;\n\n      var now = Date.now();\n      var left = ms - (now - last);\n\n      if (force || left <= 0) {\n        fn.apply(this, args);\n        last = now;\n        cancel();\n        return true;\n      }\n\n      timer = setTimeout(function () {\n        fn.apply(_this, args);\n        last = now;\n      }, left);\n      return false;\n    };\n\n    wrapper.cancel = cancel;\n    return wrapper;\n  };\n\n  var utils = {\n    isPropertyDescriptor: isPropertyDescriptor$1,\n    isThenable: isThenable$1,\n    setImmediate: _setImmediate,\n    isGenerator: isGenerator$1,\n    isGeneratorFunction: isGeneratorFunction$1,\n    EmptyObject: EmptyObject$1,\n    toGenerator: toGenerator$1,\n    toArray: toArray$1,\n    getFnType: getFnType$1,\n    lazyBindMethods: lazyBindMethods$1,\n    globalObject: globalObject$1,\n    isContextDefined: isContextDefined$2,\n    hasOwnProperty: hasOwnProperty$2,\n    getTag: getTag$2,\n    throttle: throttle$1\n  };\n  /**\n   * @module AbortController\n   */\n\n  var globalObject = utils.globalObject;\n\n  var _signal = Symbol('signal');\n\n  var _aborted = Symbol('aborted');\n\n  var _events$1 = Symbol('events');\n\n  var _abort = Symbol('abort');\n\n  var _repeatedly = Symbol('repeatedly');\n\n  var nativeAbortController = function () {\n    try {\n      var _AbortController = globalObject.AbortController;\n\n      if (typeof _AbortController === 'function') {\n        var controller = new _AbortController();\n\n        if (controller.toString() === '[object AbortController]' && controller.constructor.toString().indexOf('[native code]') !== -1) {\n          return _AbortController;\n        }\n      }\n    } catch (e) {}\n  }();\n  /**\n   * AbortSignalPolyfill class\n   * @alias CPromise.AbortSignalPolyfill\n   */\n\n\n  var AbortSignal = /*#__PURE__*/function () {\n    /**\n     * Constructs a new AbortSignal instance\n     */\n    function AbortSignal(repeatedly) {\n      _classCallCheck(this, AbortSignal);\n\n      this[_events$1] = {};\n      this[_aborted] = false;\n      this[_repeatedly] = repeatedly;\n    }\n    /**\n     * Check whether controller is aborted\n     * @returns {Boolean}\n     */\n\n\n    _createClass(AbortSignal, [{\n      key: \"addEventListener\",\n\n      /**\n       * adds a new listener to the controller\n       * @param {String|Symbol} event\n       * @param {Function} listener\n       */\n      value: function addEventListener(event, listener) {\n        var events = this[_events$1];\n        if (!events) return;\n        var listeners = events[event];\n\n        if (!listeners) {\n          events[event] = listener;\n          return;\n        }\n\n        typeof listeners === 'function' ? events[event] = [listeners, listener] : listeners.push(listener);\n      }\n      /**\n       * removes the listener\n       * @param {String|Symbol} event\n       * @param {Function} listener\n       */\n\n    }, {\n      key: \"removeEventListener\",\n      value: function removeEventListener(event, listener) {\n        var events = this[_events$1];\n        if (!events) return;\n        var listeners = events[event];\n\n        if (!listeners) {\n          return;\n        }\n\n        if (typeof listeners === 'function') {\n          events[event] = null;\n          return;\n        }\n\n        var index = listeners.indexOf(listener);\n\n        if (index !== -1) {\n          listeners.length > 1 ? listeners.splice(index, 1) : events[event] = null;\n        }\n      }\n      /**\n       * dispatch the event\n       * @param {String|Symbol} type\n       * @param {String} [reason]\n       */\n\n    }, {\n      key: \"dispatchEvent\",\n      value: function dispatchEvent(type, reason) {\n        if (!this[_events$1]) return;\n        var listener;\n        var event = {\n          type: type,\n          target: this,\n          bubbles: false,\n          cancelable: false\n        };\n        typeof (listener = this['on' + type]) === 'function' && listener.call(this, event);\n        var listeners = this[_events$1][type];\n        if (!listeners) return;\n\n        if (typeof listeners === 'function') {\n          listeners.call(this, type, event, reason);\n          return;\n        }\n\n        var length = listeners.length;\n\n        for (var i = 0; i < length; i++) {\n          listeners[i].call(this, type, event, reason);\n        }\n      }\n    }, {\n      key: _abort,\n      value: function value(reason) {\n        if (this[_repeatedly]) {\n          this.dispatchEvent('abort', reason);\n          return;\n        }\n\n        if (this[_aborted]) return;\n        this[_aborted] = true;\n        this.dispatchEvent('abort', reason);\n        this[_events$1] = null;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this[_events$1] = {};\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return '[object AbortSignal]';\n      }\n    }, {\n      key: \"aborted\",\n      get: function get() {\n        return this[_aborted];\n      }\n    }, {\n      key: Symbol.toStringTag,\n      get: function get() {\n        return 'AbortSignal';\n      }\n    }, {\n      key: \"repeatedly\",\n      get: function get() {\n        return this[_repeatedly];\n      }\n    }]);\n\n    return AbortSignal;\n  }();\n  /**\n   * AbortController class\n   */\n\n\n  var AbortController$1 = /*#__PURE__*/function () {\n    /**\n     * Constructs new AbortController instance\n     */\n    function AbortController(repeatedly) {\n      _classCallCheck(this, AbortController);\n\n      this[_signal] = null;\n      this[_repeatedly] = !!repeatedly;\n    }\n    /**\n     * returns the signal of the controller\n     * @returns {AbortSignal}\n     */\n\n\n    _createClass(AbortController, [{\n      key: \"abort\",\n\n      /**\n       * Abort the controller\n       * @param {String} [reason]\n       */\n      value: function abort(reason) {\n        this.signal[_abort](reason);\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return '[object AbortController]';\n      }\n    }, {\n      key: \"signal\",\n      get: function get() {\n        return this[_signal] || (this[_signal] = new AbortSignal(this[_repeatedly]));\n      },\n      set: function set(v) {\n        throw Error('signal is read-only property');\n      }\n    }, {\n      key: Symbol.toStringTag,\n      get: function get() {\n        return 'AbortController';\n      }\n    }]);\n\n    return AbortController;\n  }();\n\n  var isAbortSignal$2 = function isAbortSignal$2(thing) {\n    return thing && typeof thing === 'object' && typeof thing.aborted === 'boolean' && typeof thing.addEventListener === 'function' && typeof thing.removeEventListener === 'function';\n  };\n\n  var isAbortController$2 = function isAbortController$2(thing) {\n    return thing && typeof thing === 'object' && typeof thing.abort === 'function' && isAbortSignal$2(thing.signal);\n  };\n\n  var abortController = {\n    AbortController: nativeAbortController || AbortController$1,\n    AbortControllerEx: AbortController$1,\n    AbortSignalEx: AbortSignal,\n    isAbortSignal: isAbortSignal$2,\n    isAbortController: isAbortController$2\n  };\n  var isAbortSignal$1 = abortController.isAbortSignal,\n      isAbortController$1 = abortController.isAbortController;\n\n  var typify = function typify(validator, type, kind) {\n    validator.type = type;\n    kind && (validator.kind = kind);\n    return validator;\n  };\n\n  var findValidatorName = function findValidatorName(validator) {\n    var fnName = Object.keys(validators$2).find(function (key) {\n      return validators$2[key] === validator;\n    }) || validator.name;\n    return fnName ? fnName.replace(/[A-Z]/g, function (char) {\n      return '.' + char.toLowerCase();\n    }) : '';\n  };\n\n  var renderValidator = function renderValidator(validator) {\n    return validator && (validator.type || findValidatorName(validator)) || '';\n  };\n\n  var compose = function compose() {\n    for (var _len = arguments.length, validators = new Array(_len), _key = 0; _key < _len; _key++) {\n      validators[_key] = arguments[_key];\n    }\n\n    return typify(function (thing) {\n      var length = validators.length;\n\n      for (var i = 0; i < length; i++) {\n        var result = validators[i](thing);\n\n        if (result !== true) {\n          return result;\n        }\n      }\n\n      return true;\n    }, validators.map(renderValidator).join('.'));\n  };\n\n  var renderValue = function renderValue(value) {\n    return typeof value == 'string' ? \"'\".concat(value, \"'\") : String(value);\n  };\n\n  var validators$2 = {\n    null: function _null(thing) {\n      return thing === null;\n    },\n    nullable: typify(function (thing) {\n      return thing == null;\n    }, 'undefined|null'),\n    numberFinitePositive: function numberFinitePositive(thing) {\n      return typeof thing === 'number' && Number.isFinite(thing) && thing >= 0;\n    },\n    functionPlain: function functionPlain(thing) {\n      return typeof thing === 'function' && thing.constructor === Function;\n    },\n    array: function array(thing) {\n      return Array.isArray(thing);\n    },\n    union: function union() {\n      for (var _len2 = arguments.length, validators = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        validators[_key2] = arguments[_key2];\n      }\n\n      var len = validators.length;\n      var shouldBe = validators.map(renderValidator).join('|');\n      return typify(function (thing) {\n        for (var i = 0; i < len; i++) {\n          if (validators[i](thing) === true) {\n            return true;\n          }\n        }\n      }, shouldBe);\n    },\n    abortController: typify(isAbortSignal$1, 'AbortController'),\n    abortSignal: typify(isAbortController$1, 'AbortSignal'),\n    values: function values() {\n      for (var _len3 = arguments.length, _values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        _values[_key3] = arguments[_key3];\n      }\n\n      return typify(function (thing) {\n        return _values.indexOf(thing) !== -1;\n      }, _values.map(renderValue).join('|'));\n    }\n  };\n  ['object', 'boolean', 'number', 'function', 'string', 'symbol', 'undefined'].forEach(function (type, i) {\n    validators$2[type] = typify(function (thing) {\n      return typeof thing === type || \"a\".concat(i < 1 ? 'n' : '', \" \").concat(type);\n    }, type);\n  });\n  var array$1 = validators$2.array,\n      object$1 = validators$2.object,\n      union$1 = validators$2.union;\n\n  validators$2.object = function (schema, required) {\n    var allowUnknown = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var rendered = schema && Object.entries(schema).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          prop = _ref2[0],\n          validator = _ref2[1];\n\n      return \"\".concat(prop, \": \").concat(renderValidator(validator));\n    }).join(', ');\n    return schema ? compose(object$1, typify(function (thing) {\n      validateOptions$2(thing, schema, required, allowUnknown);\n      return true;\n    }, schema ? \"<\".concat(rendered, \">\") : '')) : object$1;\n  };\n\n  validators$2.array = function () {\n    var validator = arguments.length > 1 ? union$1.apply(void 0, arguments) : arguments.length <= 0 ? undefined : arguments[0];\n    return compose(array$1, typify(function (thing) {\n      return thing.every(validator);\n    }, \"<\".concat(renderValidator(validator) || '*', \">\")));\n  };\n\n  validators$2.rest = function () {\n    var validator = arguments.length > 1 ? union$1.apply(void 0, arguments) : arguments.length <= 0 ? undefined : arguments[0];\n    return typify(validator, \"...\".concat(renderValidator(validator) || '*'), 'rest');\n  };\n\n  function validateOptions$2(options, schema) {\n    var required = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var allowUnknown = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n\n    required && required.forEach(function (option) {\n      if (options[option] === undefined) {\n        throw Error(\"Option \".concat(option, \" is required\"));\n      }\n    });\n    var keys = Object.getOwnPropertyNames(options);\n    var i = keys.length;\n\n    while (i-- > 0) {\n      var option = keys[i];\n      var _validator = schema[option];\n\n      if (_validator) {\n        var value = options[option];\n\n        var result = value === undefined || _validator(value);\n\n        if (result !== true) {\n          throw TypeError(\"option '\".concat(option, \"' must be \").concat(typeof result === 'string' ? result : renderValidator(_validator)));\n        }\n\n        continue;\n      }\n\n      if (!allowUnknown) {\n        throw Error(\"Unknown option '\".concat(option, \"'\"));\n      }\n    }\n\n    return options;\n  }\n\n  function validateArguments$1(args, validators) {\n    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref3$context = _ref3.context,\n        context = _ref3$context === void 0 ? \"function\" : _ref3$context;\n\n    var length = validators.length;\n    var argsCount = args.length;\n    var restDetected;\n    var validator;\n\n    for (var i = 0; i < length; i++) {\n      if (!restDetected) {\n        validator = validators[i];\n\n        if (validator.kind === 'rest') {\n          restDetected = true;\n        }\n      }\n\n      var result = validator(args[i]);\n\n      if (result !== true) {\n        var renderedType = result || renderValidator(validator);\n        throw TypeError(\"\".concat(context, \" \").concat(i >= argsCount ? \"requires\" : \"expects\", \" \").concat(renderedType, \" as \").concat(i + 1, \"th argument\"));\n      }\n    }\n  }\n\n  var validator = {\n    validators: validators$2,\n    validateOptions: validateOptions$2,\n    validateArguments: validateArguments$1\n  };\n  /**\n   * @module CanceledError\n   */\n\n  var version$1 = env.version,\n      versionNumber$1 = env.versionNumber,\n      _version$1 = env._version,\n      _versionNumber$1 = env._versionNumber,\n      warnVersionInteraction$1 = env.warnVersionInteraction;\n  var validateOptions$1 = validator.validateOptions,\n      validators$1 = validator.validators;\n  var getTag$1 = utils.getTag;\n  var string$1 = validators$1.string,\n      number$1 = validators$1.number,\n      boolean$1 = validators$1.boolean;\n  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n  var _scope = Symbol('scope');\n\n  var _message = Symbol('message');\n\n  var _errors = Symbol('errors');\n\n  var _code = Symbol('code');\n\n  var _priority = Symbol('priority');\n\n  var _forced = Symbol('forced');\n\n  var _isCanceledError = Symbol.for('CPromise:CanceledError');\n\n  var toStringTag$1 = Symbol.toStringTag;\n\n  var isLikeCanceledError = function isLikeCanceledError(thing) {\n    return thing[_isCanceledError] || getTag$1(thing.constructor) === 'CanceledError' || thing.constructor.name === 'CanceledError' && hasOwnProperty$1.call(thing, 'scope');\n  };\n  /**\n   * CanceledError\n   */\n\n\n  var CanceledError$1 = /*#__PURE__*/function (_Error) {\n    _inherits(CanceledError, _Error);\n\n    var _super = _createSuper(CanceledError);\n\n    /**\n     * Constructs a new error instance\n     * @param {String} [message]\n     * @param {String} [code]\n     * @param {Number} [priority= 0]\n     * @param {Boolean} [forced= false]\n     */\n    function CanceledError(message) {\n      var _this2;\n\n      var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : E_REASON_CANCELED$1;\n      var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var forced = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      _classCallCheck(this, CanceledError);\n\n      _this2 = _super.call(this);\n      _this2.name = getTag$1(_this2.constructor);\n      _this2[_message] = message || 'canceled';\n      _this2[_code] = code || E_REASON_CANCELED$1;\n      _this2[_scope] = null;\n\n      if (priority !== undefined && typeof priority !== \"number\") {\n        throw TypeError('priority must be a number');\n      }\n\n      _this2[_forced] = !!forced;\n      _this2[_priority] = priority;\n      return _this2;\n    }\n    /**\n     * get promise scope where the error was raised\n     * @returns {CPromise|null}\n     */\n\n\n    _createClass(CanceledError, [{\n      key: \"scope\",\n      get: function get() {\n        return this[_scope];\n      },\n      set: function set(scope) {\n        if (!this[_scope]) {\n          this[_scope] = scope;\n          return;\n        }\n\n        throw Error('Scope has been already set');\n      }\n      /**\n       * converts thing to a CanceledError instance\n       * @param {String|Error} thing\n       * @returns {CanceledError}\n       */\n\n    }, {\n      key: \"message\",\n      get: function get() {\n        return this[_message];\n      }\n      /**\n       * get error code\n       * @returns {string}\n       */\n\n    }, {\n      key: \"code\",\n      get: function get() {\n        return this[_code] || '';\n      }\n      /**\n       * Get error priority\n       * @returns {Number}\n       */\n\n    }, {\n      key: \"priority\",\n      get: function get() {\n        return this[_priority];\n      }\n      /**\n       * Get forced flag of the error\n       * @returns {*}\n       */\n\n    }, {\n      key: \"forced\",\n      get: function get() {\n        return this[_forced];\n      }\n    }], [{\n      key: \"from\",\n      value: function from(thing) {\n        var type = typeof thing;\n\n        if (type === 'string' || thing == null) {\n          var registered = this[_errors][thing];\n\n          if (registered) {\n            this[_code] = thing;\n            this[_priority] = registered[_priority];\n            this[_forced] = registered[_forced];\n            return new CanceledError(registered.message, thing, registered.priority, registered.forced);\n          }\n\n          return new CanceledError(thing);\n        } else if (type === 'object') {\n          if (thing instanceof Error) {\n            if (thing instanceof CanceledError) {\n              return thing;\n            }\n\n            return new CanceledError(thing.message);\n          }\n        }\n\n        throw TypeError(\"unable convert \".concat(thing, \" to a CanceledError\"));\n      }\n      /**\n       * Check whether object is an instance of CanceledError\n       * @param thing\n       * @param {...string} [codes] codes to match\n       * @returns {boolean}\n       */\n\n    }, {\n      key: \"isCanceledError\",\n      value: function isCanceledError(thing) {\n        for (var _len4 = arguments.length, codes = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          codes[_key4 - 1] = arguments[_key4];\n        }\n\n        return thing && (thing instanceof this || isLikeCanceledError(thing) && warnVersionInteraction$1(thing)) && (!codes.length || codes.some(function (code) {\n          return code === thing.code;\n        }));\n      }\n    }, {\n      key: \"registerErrors\",\n      value: function registerErrors(errors) {\n        var _this3 = this;\n\n        return Object.entries(errors).reduce(function (acc, _ref4) {\n          var _ref5 = _slicedToArray(_ref4, 2),\n              name = _ref5[0],\n              entry = _ref5[1];\n\n          Object.defineProperty(_this3, name, {\n            value: name\n          });\n\n          if (typeof entry === 'object') {\n            validateOptions$1(entry, {\n              message: string$1,\n              priority: number$1,\n              forced: boolean$1\n            });\n          } else {\n            entry = {\n              message: typeof entry === 'symbol' ? String(entry).slice(7, -1) : entry\n            };\n          }\n\n          _this3[_errors][name] = entry;\n          acc[name] = name;\n          return acc;\n        }, {});\n      }\n      /**\n       * Rethrow the canceled error with optional codes matching\n       * @param err an error to assert\n       * @param {...String} [codes]\n       * @throws CanceledError\n       */\n\n    }, {\n      key: \"rethrow\",\n      value: function rethrow(err) {\n        if (!this.isCanceledError(err)) {\n          return;\n        }\n\n        for (var _len5 = arguments.length, codes = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n          codes[_key5 - 1] = arguments[_key5];\n        }\n\n        var length = codes.length;\n\n        if (!length) {\n          throw err;\n        } else {\n          var code = err.code;\n\n          for (var i = 0; i < length; i++) {\n            var targetCode = codes[i];\n\n            if (typeof targetCode !== 'string') {\n              throw TypeError(\"CanceledError code passed as the \".concat(i + 1, \"th argument must be a string, got \").concat(targetCode));\n            }\n\n            if (targetCode === code) {\n              throw err;\n            }\n          }\n        }\n      }\n    }, {\n      key: toStringTag$1,\n      get: function get() {\n        return 'CanceledError';\n      }\n    }]);\n\n    return CanceledError;\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n  Object.defineProperties(CanceledError$1.prototype, (_Object$definePropert = {}, _defineProperty(_Object$definePropert, _version$1, {\n    value: version$1\n  }), _defineProperty(_Object$definePropert, _versionNumber$1, {\n    value: versionNumber$1\n  }), _Object$definePropert));\n  Object.defineProperties(CanceledError$1.prototype, _defineProperty({}, _isCanceledError, {\n    value: true\n  }));\n  CanceledError$1[_errors] = {};\n\n  var _CanceledError$1$regi = CanceledError$1.registerErrors({\n    E_REASON_CANCELED: 'canceled',\n    E_REASON_TIMEOUT: 'timeout',\n    E_REASON_DISPOSED: 'disposed',\n    E_REASON_UNMOUNTED: {\n      message: 'component unmounted',\n      priority: Infinity,\n      forced: true\n    }\n  }),\n      E_REASON_CANCELED$1 = _CanceledError$1$regi.E_REASON_CANCELED;\n\n  var canceledError = {\n    CanceledError: CanceledError$1\n  };\n  var validateArguments = validator.validateArguments;\n  var isContextDefined$1 = utils.isContextDefined,\n      isPropertyDescriptor = utils.isPropertyDescriptor,\n      hasOwnProperty = utils.hasOwnProperty;\n\n  var isModernDescriptor = function isModernDescriptor(thing) {\n    return thing && typeof thing === 'object' && thing[Symbol.toStringTag] === 'Descriptor';\n  };\n\n  var isAnyPropertyDecoratorDescriptor = function isAnyPropertyDecoratorDescriptor(arg0, arg1, arg2) {\n    if (arguments.length === 1) {\n      return isModernDescriptor(arg0);\n    }\n\n    if (arguments.length === 3) {\n      return isPropertyDescriptor(arg2);\n    }\n  };\n\n  function reducePropertyDecorator(decorator) {\n    return function (arg0, arg1, arg2) {\n      if (arguments.length === 1) {\n        return decorator(arg0);\n      } else {\n        var _decorator$call = decorator.call(null, {\n          key: arg1,\n          kind: \"method\",\n          placement: typeof arg0 === \"function\" ? \"static\" : \"prototype\",\n          descriptor: arg2\n        }),\n            descriptor = _decorator$call.descriptor,\n            finisher = _decorator$call.finisher;\n\n        finisher && finisher(arg0.constructor);\n        return descriptor;\n      }\n    };\n  }\n\n  var assertDecoratorArgs = function assertDecoratorArgs(decoratorName, args, validators) {\n    validators && validateArguments(args, validators, {\n      context: \"@\".concat(decoratorName, \" decorator\")\n    });\n  };\n\n  var fail = function fail(decoratorName, message) {\n    throw Error(\"@\".concat(decoratorName, \": \").concat(message));\n  };\n\n  var propertyDecorator$1 = function propertyDecorator$1(builder, argsTypes, hook) {\n    return function (name, context) {\n      function decorator() {\n        for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          params[_key6] = arguments[_key6];\n        }\n\n        assertDecoratorArgs(name, params, argsTypes);\n        return reducePropertyDecorator(function (descriptor) {\n          if (descriptor.kind !== 'field' && descriptor.kind !== 'method') {\n            throw Error(\"\".concat(name, \" decorator can be used for method or field\"));\n          }\n\n          return builder(descriptor, params, {\n            context: context,\n            fail: fail.bind(null, name),\n            name: name\n          });\n        });\n      }\n\n      return function () {\n        var hookResult = hook && isContextDefined$1(this) ? hook.apply(this, arguments) : undefined;\n\n        if (hookResult !== undefined) {\n          return hookResult;\n        }\n\n        if (isAnyPropertyDecoratorDescriptor.apply(null, arguments)) {\n          return decorator().apply(null, arguments);\n        }\n\n        return decorator.apply(null, arguments);\n      };\n    };\n  };\n\n  function reduceClassDecorator(decorator) {\n    return function (arg0) {\n      if (arguments.length === 1) {\n        if (typeof arg0 === 'function') {\n          var _decorator = decorator({\n            kind: \"class\"\n          }),\n              descriptor = _decorator.descriptor,\n              finisher = _decorator.finisher;\n\n          finisher && finisher(arg0);\n          return descriptor;\n        } else if (isModernDescriptor(arg0)) {\n          return decorator(arg0);\n        }\n      }\n\n      throw new Error('cannot recognize decorator calling context');\n    };\n  }\n\n  function isClassDecoratorContext(arg0) {\n    return arguments.length === 1 && typeof arg0 === 'function' || isModernDescriptor(arg0);\n  }\n\n  var classDecorator$1 = function classDecorator$1(builder, argsTypes, hook) {\n    return function (name, context) {\n      var decorator = function decorator() {\n        for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          params[_key7] = arguments[_key7];\n        }\n\n        assertDecoratorArgs(name, params, argsTypes);\n        return reduceClassDecorator(function (descriptor) {\n          if (descriptor.kind !== 'class') {\n            fail(name, 'can only be used for classes');\n          }\n\n          return builder(descriptor, params, {\n            context: context,\n            fail: fail.bind(null, name),\n            name: name\n          });\n        });\n      };\n\n      return function (arg0) {\n        var hookResult = hook && isContextDefined$1(this) ? hook.apply(this, arguments) : undefined;\n\n        if (hookResult !== undefined) {\n          return hookResult;\n        }\n\n        if (isClassDecoratorContext.apply(null, arguments)) {\n          return decorator().apply(null, arguments);\n        }\n\n        return decorator.apply(null, arguments);\n      };\n    };\n  };\n\n  var bindDecorators$1 = function bindDecorators$1(context, decorators) {\n    var descriptors = {};\n    Object.entries(decorators).forEach(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n          name = _ref7[0],\n          decorator = _ref7[1];\n\n      var symbol = Symbol(\"\".concat(name, \"Bound\"));\n      descriptors[name] = {\n        get: function get() {\n          return hasOwnProperty.call(this, symbol) ? this[symbol] : this[symbol] = decorator(name, this);\n        },\n        configurable: true,\n        enumerable: true\n      };\n    });\n    Object.defineProperties(context, descriptors);\n  };\n\n  var decorators$1 = {\n    propertyDecorator: propertyDecorator$1,\n    classDecorator: classDecorator$1,\n    bindDecorators: bindDecorators$1\n  };\n  /**\n   * Cancellable Promise with extra features\n   * @module CPromise\n   */\n\n  /**\n   * @typedef {String|Symbol} EventType\n   */\n\n  var CanceledError = canceledError.CanceledError;\n  var E_REASON_CANCELED = CanceledError.E_REASON_CANCELED,\n      E_REASON_TIMEOUT = CanceledError.E_REASON_TIMEOUT,\n      E_REASON_DISPOSED = CanceledError.E_REASON_DISPOSED,\n      E_REASON_UNMOUNTED = CanceledError.E_REASON_UNMOUNTED;\n  var AbortController = abortController.AbortController,\n      AbortControllerEx = abortController.AbortControllerEx,\n      isAbortSignal = abortController.isAbortSignal,\n      isAbortController = abortController.isAbortController;\n  var validateOptions = validator.validateOptions,\n      validators = validator.validators;\n  var isThenable = utils.isThenable,\n      EmptyObject = utils.EmptyObject,\n      setImmediate$1 = utils.setImmediate,\n      isGeneratorFunction = utils.isGeneratorFunction,\n      isGenerator = utils.isGenerator,\n      toGenerator = utils.toGenerator,\n      toArray = utils.toArray,\n      getFnType = utils.getFnType,\n      lazyBindMethods = utils.lazyBindMethods,\n      isContextDefined = utils.isContextDefined,\n      getTag = utils.getTag,\n      throttle = utils.throttle,\n      toFixed = utils.toFixed;\n  var classDecorator = decorators$1.classDecorator,\n      propertyDecorator = decorators$1.propertyDecorator,\n      bindDecorators = decorators$1.bindDecorators;\n  var versionNumber = env.versionNumber,\n      _versionNumber = env._versionNumber,\n      _version = env._version,\n      version = env.version,\n      warnVersionInteraction = env.warnVersionInteraction;\n  var union = validators.union,\n      array = validators.array,\n      functionPlain = validators.functionPlain,\n      numberFinitePositive = validators.numberFinitePositive,\n      number = validators.number,\n      boolean = validators.boolean,\n      string = validators.string,\n      symbol = validators.symbol,\n      object = validators.object,\n      rest = validators.rest,\n      nullable = validators.nullable;\n  var now = Date.now;\n  var isArray = Array.isArray;\n\n  var _toCPromise = Symbol.for('toCPromise');\n\n  var _isCPromise = Symbol.for('isCPromise');\n\n  var _shadow = Symbol('shadow');\n\n  var _events = Symbol('events');\n\n  var _resolve = Symbol('done');\n\n  var _setInnerChain = Symbol('setInnerChain');\n\n  var _promisified = Symbol('promisified');\n\n  var _render = Symbol('render');\n\n  var toStringTag = Symbol.toStringTag;\n  var TYPE_PROGRESS = Symbol('TYPE_PROGRESS');\n  var TYPE_PAUSE = Symbol('TYPE_PAUSE');\n  var TYPE_RESUME = Symbol('TYPE_RESUME');\n  var SIGNAL_CANCEL = Symbol('SIGNAL_CANCEL');\n  var SIGNAL_PAUSE = Symbol('SIGNAL_PAUSE');\n  var SIGNAL_RESUME = Symbol('SIGNAL_RESUME');\n  var ATOMIC_TYPE_DISABLED = 0;\n  var ATOMIC_TYPE_DETACHED = 1;\n  var ATOMIC_TYPE_AWAIT = 2;\n\n  var noop = function noop() {};\n\n  var atomicMap = new Map([['disabled', ATOMIC_TYPE_DISABLED], ['detached', ATOMIC_TYPE_DETACHED], ['await', ATOMIC_TYPE_AWAIT], [false, ATOMIC_TYPE_DISABLED], [true, ATOMIC_TYPE_AWAIT], [ATOMIC_TYPE_DISABLED, ATOMIC_TYPE_DISABLED], [ATOMIC_TYPE_DETACHED, ATOMIC_TYPE_DETACHED], [ATOMIC_TYPE_AWAIT, ATOMIC_TYPE_AWAIT]]);\n  var controllersStore = new WeakMap();\n\n  var computeWeightSum = function computeWeightSum(promises) {\n    var i = promises.length;\n    var sum = 0;\n\n    while (i-- > 0) {\n      sum += promises[i][_shadow].weight;\n    }\n\n    return sum;\n  };\n  /**\n   * @typedef {Function} CPromiseExecutorFn\n   * @this CPromise\n   * @param {Function} resolve\n   * @param {Function} reject\n   * @param {CPromise} scope\n   */\n\n  /**\n   * @typedef {Object} PromiseOptionsObject\n   * @property {String} label\n   * @property {Number} timeout\n   * @property {Number} weight\n   * @property {Boolean} [nativeController= false] prefer native AbortController class as the internal signal\n   */\n\n  /**\n   * If value is a number it will be considered as the value for timeout option\n   * If value is a string it will be considered as a label\n   * @typedef {PromiseOptionsObject|String|Number} CPromiseOptions\n   */\n\n  /**\n   * CPromise class\n   * @namespace\n   * @extends Promise\n   */\n\n\n  var CPromise$1 = /*#__PURE__*/function (_Promise) {\n    _inherits(CPromise, _Promise);\n\n    var _super2 = _createSuper(CPromise);\n\n    /**\n     * Creates a new CPromise instance\n     * @param {CPromiseExecutorFn} [executor] - promise executor function that will be invoked\n     * in the context of the new CPromise instance\n     * @param {CPromiseOptions} [options]\n     */\n    function CPromise(executor, options) {\n      var _this4;\n\n      _classCallCheck(this, CPromise);\n\n      if (options !== undefined && options !== null) {\n        switch (typeof options) {\n          case 'string':\n            options = {\n              label: options\n            };\n            break;\n\n          case 'number':\n            options = {\n              timeout: options\n            };\n            break;\n\n          case 'object':\n            break;\n\n          default:\n            throw TypeError('options must be an object|string|number');\n        }\n      }\n\n      var _ref8 = options || {},\n          label = _ref8.label,\n          weight = _ref8.weight,\n          timeout = _ref8.timeout,\n          signal = _ref8.signal,\n          _ref8$nativeControlle = _ref8.nativeController,\n          nativeController = _ref8$nativeControlle === void 0 ? false : _ref8$nativeControlle;\n\n      var resolve, reject;\n      _this4 = _super2.call(this, function (_resolve, _reject) {\n        resolve = _resolve;\n        reject = _reject;\n      });\n      _this4[_events] = new EmptyObject();\n      var shadow = _this4[_shadow] = {\n        resolve: resolve,\n        reject: reject,\n        leafsCount: 0,\n        paused: false,\n        timestamp: -1,\n        innerChain: null,\n        parent: null,\n        progress: 0,\n        computedProgress: -1,\n        totalWeight: -1,\n        innerWeight: 1,\n        throttle: 0,\n        throttleTimer: 0,\n        isCaptured: false,\n        isListening: false,\n        isPending: true,\n        isCanceled: false,\n        isRejected: false,\n        isChain: true,\n        label: '',\n        weight: 1,\n        value: undefined,\n        nativeController: nativeController,\n        atomic: ATOMIC_TYPE_DISABLED,\n        canceledWith: null\n      };\n      signal !== undefined && _this4.listen(signal);\n      timeout !== undefined && _this4.timeout(timeout);\n      weight !== undefined && _this4.weight(weight);\n      label !== undefined && _this4.label(label);\n\n      _this4.on('propagate', function (type, scope, data) {\n        switch (type) {\n          case TYPE_PROGRESS:\n            shadow.computedProgress = -1;\n            shadow.isListening && _this4.emit('progress', _this4.progress(), scope, data);\n            return;\n\n          case TYPE_PAUSE:\n            _this4.emit('pause', data, scope);\n\n            return;\n\n          case TYPE_RESUME:\n            _this4.emit('resume', data, scope);\n\n        }\n      });\n\n      _this4.on('newListener', function (event) {\n        if (event === 'progress') {\n          shadow.isListening = true;\n\n          if (!shadow.isCaptured) {\n            _this4.captureProgress();\n          }\n        }\n      });\n\n      _this4.on('removeListener', function (event) {\n        if (event === 'progress') {\n          if (shadow.isListening && !_this4.hasListeners('progress')) {\n            shadow.isListening = false;\n          }\n        }\n      });\n\n      if (executor != null) {\n        if (typeof executor !== 'function') {\n          throw TypeError('CPromise executor is not a function');\n        }\n\n        try {\n          executor.call(_assertThisInitialized(_this4), function (value) {\n            _this4.resolve(value);\n          }, function (err) {\n            _this4.reject(err);\n          }, _assertThisInitialized(_this4));\n        } catch (err) {\n          _this4.reject(err);\n        }\n      }\n\n      return _this4;\n    }\n    /**\n     * @typedef {Function} OnCancelListener\n     * @param {CanceledError} reason\n     */\n\n    /**\n     * @typedef {Function} OnPauseListener\n     */\n\n    /**\n     * @typedef {Function} OnResumeListener\n     */\n\n    /**\n     * @typedef {Function} OnCaptureListener\n     * @param {scope} CPromise\n     */\n\n    /**\n     * registers the listener for cancel event\n     * @param {OnCancelListener} listener\n     * @returns {CPromise}\n     */\n\n\n    _createClass(CPromise, [{\n      key: \"onCancel\",\n      value: function onCancel(listener) {}\n      /**\n       * registers the listener for pause event\n       * @param {OnPauseListener} listener\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"onPause\",\n      value: function onPause(listener) {}\n      /**\n       * registers the listener for resume event\n       * @param {OnResumeListener} listener\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"onResume\",\n      value: function onResume(listener) {}\n      /**\n       * registers the listener for capture event\n       * @param {OnCaptureListener} listener\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"onCapture\",\n      value: function onCapture(listener) {}\n      /**\n       * @typedef {function} CPDoneListener\n       * @param {*} value\n       * @param {boolean} isRejected\n       * @returns {CPromise}\n       */\n\n      /**\n       * registers the listener for done event\n       * @param {CPDoneListener} listener\n       */\n\n    }, {\n      key: \"onDone\",\n      value: function onDone(listener) {}\n      /**\n       * @typedef {function} CPSignalListener\n       * @param {Signal} type\n       * @param {*} data\n       * @returns {Boolean}\n       */\n\n      /**\n       *  registers the listener for done event\n       * @param {CPSignalListener} listener\n       */\n\n      /**\n      * registers the listener for done event\n      * @param {Signal} signal\n      * @param {CPSignalListener} listener\n      */\n\n    }, {\n      key: \"onSignal\",\n      value: function onSignal(signal, listener) {\n        if (arguments.length === 1) {\n          listener = signal;\n          signal = null;\n        }\n\n        return this.on('signal', function (_signal, data) {\n          if (signal && signal !== _signal) return;\n          return signal ? listener.call(this, data) : listener.call(this, _signal, data);\n        });\n      }\n      /**\n       * Set or get the total weight of the inner chains\n       * @param {Number} [weight]\n       * @return {Number|CPromise}\n       */\n\n    }, {\n      key: \"totalWeight\",\n      value: function totalWeight(weight) {\n        if (arguments.length) {\n          if (weight <= 0 || !Number.isFinite(weight)) {\n            throw Error('weight must be a number greater than 0');\n          }\n\n          this[_shadow].totalWeight = weight;\n          return this;\n        }\n\n        return this[_shadow].totalWeight;\n      }\n      /**\n       * Set or get the total weight of the inner chains\n       * @param {Number} [weight]\n       * @return {Number|CPromise}\n       */\n\n    }, {\n      key: \"innerWeight\",\n      value: function innerWeight(weight) {\n        if (arguments.length) {\n          if (!Number.isFinite(weight)) {\n            throw Error('inner weight must be a number');\n          }\n\n          if (weight < 0) {\n            throw Error('inner weight cannot be less than 0');\n          }\n\n          this[_shadow].innerWeight = weight;\n          return this;\n        }\n\n        return this[_shadow].innerWeight;\n      }\n      /**\n       * Subscribe to progress event\n       * @param {Function} listener\n       * @returns {CPromise}\n       */\n\n      /**\n       * Set promise progress\n       * @param {Number} [value] a number between [0, 1]\n       * @param {*} [data] any data to send for progress event listeners\n       * @param {CPromise} [scope] CPromise scope\n       * @returns {Number|CPromise}\n       */\n\n    }, {\n      key: \"progress\",\n      value: function progress(value, data, scope) {\n        var shadow = this[_shadow];\n\n        if (arguments.length) {\n          if (!shadow.isPending) return this;\n\n          if (typeof value === 'function') {\n            this.on('progress', value);\n            return this;\n          }\n\n          if (!Number.isFinite(value)) {\n            throw TypeError('value must be a number [0, 1]');\n          }\n\n          if (!shadow.isCaptured) return this;\n\n          if (value < 0) {\n            value = 0;\n          } else if (value > 1) {\n            value = 1;\n          }\n\n          if (value !== 0 && value !== 1) {\n            value = +value.toFixed(10);\n          }\n\n          if (shadow.progress !== value) {\n            shadow.progress = value;\n\n            if (value !== 1 && shadow.throttler) {\n              shadow.throttler([data, scope]);\n            } else {\n              this.propagate(TYPE_PROGRESS, data, scope);\n            }\n          }\n\n          return this;\n        }\n\n        if (shadow.computedProgress === -1) {\n          shadow.totalWeight === -1 && this.captureProgress();\n          var scopes = this.scopes(true);\n          var i = scopes.length;\n          var sum = 0;\n          var _progress = 0;\n\n          while (i-- > 0) {\n            var _scope2 = scopes[i];\n            var thatShadow = _scope2[_shadow];\n            var weight = thatShadow.weight;\n\n            if (weight > 0) {\n              sum += weight;\n              _progress += thatShadow.progress * weight;\n            }\n          }\n\n          var total = shadow.totalWeight;\n          shadow.computedProgress = total > 0 ? (_progress + (total - sum)) / total : _progress / sum;\n        }\n\n        return shadow.computedProgress;\n      }\n      /**\n       * emit propagate event that will propagate through each promise scope in the chain (bubbling)\n       * @param {String|symbol} type - some type to identify the data kind\n       * @param {*?} data - some data\n       * @param {CPromise} [scope] - CPromise scope\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"propagate\",\n      value: function propagate(type) {\n        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        return this.emit('propagate', type, scope || this, data);\n      }\n      /**\n       * capture initial progress state of the chain\n       * @param {Object} [options]\n       * @param {Number} options.throttle set min interval for firing progress event\n       * @param {Number} options.innerWeight set weight of the nested promises\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"captureProgress\",\n      value: function captureProgress(options) {\n        var _this5 = this;\n\n        var shadow = this[_shadow];\n\n        if (options) {\n          validateOptions(options, {\n            throttle: numberFinitePositive,\n            innerWeight: numberFinitePositive\n          });\n        }\n\n        var _ref9 = options || {},\n            _ref9$throttle = _ref9.throttle,\n            ms = _ref9$throttle === void 0 ? 250 : _ref9$throttle,\n            innerWeight = _ref9.innerWeight;\n\n        shadow.throttler && shadow.throttler.cancel();\n        shadow.throttler = ms ? throttle(function (data, scope) {\n          _this5.propagate(TYPE_PROGRESS, data, scope);\n        }, ms) : null;\n\n        if (innerWeight !== undefined) {\n          this.innerWeight(innerWeight);\n        }\n\n        var scopes = this.scopes(true);\n        var i = scopes.length;\n        var sum = 0;\n\n        while (i-- > 0) {\n          var _scope3 = scopes[i];\n          var thatShadow = _scope3[_shadow];\n          var weight = thatShadow.weight;\n\n          if (weight > 0) {\n            sum += weight;\n\n            if (!thatShadow.isCaptured) {\n              thatShadow.isCaptured = true;\n\n              _scope3.emit('capture', _scope3);\n            }\n\n            var inner = thatShadow.innerChain;\n\n            if (inner && !inner[_shadow].isCaptured) {\n              inner.captureProgress(options);\n            }\n          }\n        }\n\n        if (shadow.totalWeight === -1) {\n          shadow.totalWeight = sum;\n        }\n\n        return this;\n      }\n      /**\n       * Returns all parent scopes that are in pending state\n       * @param {boolean} [pendingOnly= false]\n       * @returns {CPromise[]}\n       */\n\n    }, {\n      key: \"scopes\",\n      value: function scopes(pendingOnly) {\n        var scope = this;\n        var scopes = [scope];\n\n        while ((scope = scope[_shadow].parent) && (!pendingOnly || scope[_shadow].isPending)) {\n          scopes.push(scope);\n        }\n\n        return scopes;\n      }\n      /**\n       * timeout before the promise will be canceled\n       * @param {Number} [ms] - timeout in ms\n       * @returns {Number|CPromise}\n       */\n\n    }, {\n      key: \"timeout\",\n      value: function timeout(ms) {\n        var _this6 = this;\n\n        var shadow = this[_shadow];\n\n        if (arguments.length) {\n          if (shadow.timer) {\n            shadow.timestamp = -1;\n            clearTimeout(shadow.timer);\n            shadow.timer = null;\n          }\n\n          if (typeof ms !== 'number' || ms < 0) {\n            throw TypeError('timeout must be a positive number');\n          }\n\n          if (ms > 0) {\n            shadow.timestamp = now();\n            shadow.timer = setTimeout(function () {\n              _this6.cancel(E_REASON_TIMEOUT);\n            }, shadow.timeout = ms);\n          }\n\n          return this;\n        }\n\n        return shadow.timeout;\n      }\n      /**\n       * get promise abort signal object\n       * @type {AbortSignal}\n       */\n\n    }, {\n      key: \"weight\",\n\n      /**\n       * Sets the promise weight in progress capturing process\n       * @param {Number} [weight] - any number greater or equal 0\n       * @returns {Number|CPromise} returns weight if no arguments were specified\n       */\n      value: function weight(_weight) {\n        if (arguments.length) {\n          if (typeof _weight !== 'number') {\n            throw TypeError('weight must be a number');\n          }\n\n          if (_weight < 0) {\n            throw Error('weight must must be a positive number');\n          }\n\n          this[_shadow].weight = _weight;\n          return this;\n        }\n\n        return this[_shadow].weight;\n      }\n      /**\n       * Sets the promise label\n       * @param {String} [label] - any string\n       * @returns {Number|CPromise} returns weight if no arguments were specified\n       */\n\n    }, {\n      key: \"label\",\n      value: function label(_label) {\n        if (arguments.length) {\n          this[_shadow].label = _label;\n          return this;\n        }\n\n        return this[_shadow].label;\n      }\n      /**\n       * indicates if the promise is pending\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"resolve\",\n\n      /**\n       * Resolves the promise with given value\n       * @param value\n       * @returns {CPromise}\n       */\n      value: function resolve(value) {\n        this[_resolve](value, false);\n\n        return this;\n      }\n      /**\n       * Rejects the promise with given error\n       * @param err\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"reject\",\n      value: function reject(err) {\n        this[_resolve](err, true);\n\n        return this;\n      }\n    }, {\n      key: _setInnerChain,\n      value: function value(chain) {\n        var _this7 = this;\n\n        var captureProgress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var shadow = this[_shadow];\n        shadow.innerChain = chain;\n        chain.on('propagate', function (type, scope, data) {\n          if (type === TYPE_PROGRESS) {\n            if (!captureProgress || !shadow.isCaptured) return;\n\n            var _progress2 = chain.progress();\n\n            _this7.progress(_progress2, data);\n\n            return;\n          }\n\n          _this7.emit('propagate', type, scope, data);\n        });\n\n        if (captureProgress) {\n          shadow.isCaptured && chain.captureProgress();\n          shadow.innerWeight = chain[_shadow].totalWeight;\n        }\n      }\n    }, {\n      key: _resolve,\n      value: function value(_value, isRejected) {\n        var _this8 = this;\n\n        var shadow = this[_shadow];\n        if (!shadow.isPending) return this;\n\n        var complete = function complete(value, isRejected) {\n          if (shadow.timer) {\n            clearTimeout(shadow.timer);\n            shadow.timer = null;\n          }\n\n          var resolve = function resolve() {\n            shadow.isRejected = isRejected;\n            shadow.value = value;\n\n            if (isRejected) {\n              shadow.isCanceled && !shadow.leafsCount && _get(_getPrototypeOf(CPromise.prototype), \"then\", _this8).call(_this8, null, noop);\n\n              _this8.emit('done', value, isRejected);\n\n              shadow.reject(value);\n            } else {\n              shadow.isCaptured && _this8.progress(1);\n\n              _this8.emit('done', value, isRejected);\n\n              shadow.resolve(value);\n            }\n\n            shadow.isPending = false;\n            shadow.innerChain = null;\n            shadow.parent && shadow.parent[_shadow].leafsCount--;\n            shadow.parent = null;\n            _this8[_events] = null;\n          };\n\n          if (isRejected && value && CanceledError.isCanceledError(value)) {\n            shadow.isCanceled = true;\n            value.scope || (value.scope = _this8);\n\n            if (shadow.controller) {\n              shadow.controller.abort();\n              shadow.controller = null;\n            }\n\n            _this8.emit('cancel', value);\n\n            resolve();\n            return;\n          }\n\n          if (shadow.paused) {\n            return _this8.on('resume', resolve);\n          }\n\n          resolve();\n        };\n\n        if (!isRejected && shadow.canceledWith) {\n          complete(shadow.canceledWith, true);\n        }\n\n        if (!isThenable(_value)) {\n          complete(_value, isRejected);\n          return;\n        }\n\n        if (this.constructor.isCPromise(_value)) {\n          this[_setInnerChain](_value);\n        }\n\n        _value.then(function (value) {\n          complete(value);\n        }, function (err) {\n          complete(err, true);\n        });\n      }\n      /**\n       * Pause promise\n       * @param {*} data\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"pause\",\n      value: function pause(data) {\n        return this.emitSignal(SIGNAL_PAUSE, null, function () {\n          var shadow = this[_shadow];\n\n          if (!shadow.paused) {\n            shadow.paused = true;\n\n            if (shadow.timer) {\n              clearTimeout(shadow.timer);\n              shadow.timer = null;\n              shadow.timestamp !== -1 && (shadow.timeLeft = now() - shadow.timestamp);\n            }\n\n            this.propagate(TYPE_PAUSE, data);\n          }\n\n          return true;\n        });\n      }\n      /**\n       * Resume promise\n       * @param {*} data\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"resume\",\n      value: function resume(data) {\n        return this.emitSignal(SIGNAL_RESUME, null, function () {\n          var shadow = this[_shadow];\n\n          if (shadow.paused) {\n            shadow.paused = false;\n\n            if (shadow.timeLeft) {\n              this.timeout(shadow.timeLeft);\n              shadow.timeLeft = 0;\n            }\n\n            this.propagate(TYPE_RESUME, data);\n          }\n\n          return true;\n        });\n      }\n      /**\n       * @typedef {number|boolean|\"disabled\"|\"detached\"|\"await\"} AtomicType\n       */\n\n      /**\n       * Make promise chain atomic (non-cancellable for external signals)\n       * @param {AtomicType} [type]\n       * @returns CPromise\n       */\n\n    }, {\n      key: \"atomic\",\n      value: function atomic() {\n        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ATOMIC_TYPE_AWAIT;\n\n        var _type = atomicMap.get(type);\n\n        if (_type === undefined) {\n          throw Error(\"Unknown atomic type '\".concat(type, \"'\"));\n        }\n\n        this[_shadow].atomic = _type;\n        return this;\n      }\n      /**\n       * throws the CanceledError that cause promise chain cancellation\n       * @param {String|Error} [reason]\n       * @param {Boolean} [forced= false]\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel(reason) {\n        var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var ignoreCancelError = false;\n        var err = CanceledError.from(reason);\n        return this.emitSignal(SIGNAL_CANCEL, {\n          err: err,\n          force: forced || err.forced\n        }, function (_ref10) {\n          var err = _ref10.err;\n          !ignoreCancelError && !this[_shadow].canceledWith && this.reject(err);\n          return true;\n        }, function (_ref11, type, scope, isRoot) {\n          var err = _ref11.err,\n              force = _ref11.force;\n          var shadow = scope[_shadow];\n          var atomic = shadow.atomic,\n              parent = shadow.parent;\n\n          if (parent) {\n            var _parent$_shadow = parent[_shadow],\n                isCanceled = _parent$_shadow.isCanceled,\n                value = _parent$_shadow.value;\n\n            if (isCanceled && err.priority <= value.priority) {\n              ignoreCancelError = true;\n              return false;\n            }\n          }\n\n          if (atomic === ATOMIC_TYPE_DETACHED) {\n            return false;\n          }\n\n          if (atomic === ATOMIC_TYPE_AWAIT) {\n            shadow.canceledWith = err;\n            return true;\n          }\n\n          if (!isRoot && !force && scope[_shadow].leafsCount > 1) {\n            return false;\n          }\n        });\n      }\n      /**\n       * @typedef {String|Symbol} Signal\n       */\n\n      /**\n       * @typedef {Function} SignalHandler\n       * @param {*} data\n       * @param {Signal} type\n       * @param {CPromise} scope\n       * @this {CPromise}\n       * @returns {Boolean}\n       */\n\n      /**\n       * @typedef {Function} SignalLocator\n       * @param {*} data\n       * @param {Signal} type\n       * @param {CPromise} scope\n       * @param {Boolean} isRoot\n       * @this {CPromise}\n       * @returns {Boolean}\n       */\n\n      /**\n       * Emit a signal of the specific type\n       * @param {Signal} type\n       * @param {*} [data]\n       * @param {SignalHandler} [handler]\n       * @param {SignalLocator} [locator]\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"emitSignal\",\n      value: function emitSignal(type, data, handler, locator) {\n        var emit = function emit(scope, isRoot) {\n          var shadow = scope[_shadow];\n          if (!shadow.isPending) return false;\n          var locatorResult = locator ? locator.call(scope, data, type, scope, isRoot) : undefined;\n\n          if (locatorResult === false) {\n            return false;\n          }\n\n          if (locatorResult !== true) {\n            var parent = shadow.parent,\n                innerChain = shadow.innerChain;\n\n            if (parent && emit(parent, false)) {\n              return true;\n            }\n\n            if (innerChain && emit(innerChain, false)) {\n              return true;\n            }\n          }\n\n          return !!(scope.emitHook('signal', type, data) || handler && handler.call(scope, data, type, scope));\n        };\n\n        return emit(this, true);\n      }\n      /**\n       * Returns a chain that will be resolved after specified timeout\n       * @param {Number} ms\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"delay\",\n      value: function delay(ms) {\n        var _this9 = this;\n\n        return this.then(function (value) {\n          return _this9.constructor.delay(ms, value);\n        });\n      }\n      /**\n       * Aggregate promise chain into one promise\n       * @param {number} [weight=1]\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"aggregate\",\n      value: function aggregate() {\n        var _this10 = this;\n\n        var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var promise = new this.constructor(function (resolve) {\n          return resolve(_this10);\n        });\n        return weight !== 1 ? promise.weight(weight) : promise;\n      }\n      /**\n       * returns a CPromise. It takes up to two arguments: callback functions for the success and failure cases of the Promise.\n       * @param {onFulfilled} onFulfilled\n       * @param {onRejected} [onRejected]\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"then\",\n      value: function then(onFulfilled, onRejected) {\n        var _this11 = this;\n\n        if (onFulfilled != null && typeof onFulfilled !== 'function') {\n          throw TypeError('onFulfilled is not a function');\n        }\n\n        if (onRejected != null && typeof onRejected !== 'function') {\n          throw TypeError('onRejected is not a function');\n        }\n\n        var resolve = function resolve(value, isRejected) {\n          var shadow = promise[_shadow];\n          var canceled = shadow.isCanceled;\n\n          if (canceled) {\n            isRejected = true;\n            value = shadow.value;\n          } else {\n            if (isRejected && CanceledError.isCanceledError(value)) {\n              shadow.isCanceled = true;\n            }\n          }\n\n          var cb = isRejected ? onRejected || function (err) {\n            if (!canceled) {\n              throw err;\n            }\n          } : onFulfilled;\n          return isGeneratorFunction(cb) ? _this11.constructor.run(cb, {\n            resolveSignatures: true,\n            args: [value]\n          }) : cb.call(promise, value, promise);\n        };\n\n        var promise = _get(_getPrototypeOf(CPromise.prototype), \"then\", this).call(this, onFulfilled ? resolve : function (value) {\n          if (_this11[_shadow].isCanceled) {\n            promise[_shadow].isCanceled = true;\n          }\n\n          return value;\n        }, function (err) {\n          return resolve(err, true);\n        });\n\n        promise[_shadow].parent = this;\n        this[_shadow].leafsCount++;\n        this.on('propagate', function (type, scope, data) {\n          promise.emit('propagate', type, scope, data);\n        });\n        return promise;\n      }\n      /**\n       * Catches rejection with optionally specified Error class\n       * @param {Function} onRejected\n       * @param {Error} [filter]\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"catch\",\n      value: function _catch(onRejected, filter) {\n        if (filter) {\n          return _get(_getPrototypeOf(CPromise.prototype), \"catch\", this).call(this, function (err, scope) {\n            if (err instanceof filter) {\n              return onRejected.call(scope, err, scope);\n            }\n\n            throw err;\n          });\n        }\n\n        return _get(_getPrototypeOf(CPromise.prototype), \"catch\", this).call(this, onRejected);\n      }\n      /**\n       * @typedef {function} CPFinallyHandler\n       * @param {*} settledValue\n       * @param {boolean} isRejected\n       * @param {CPromise} scope\n       * @this CPromise\n       */\n\n      /**\n       * Add handler that will be invoked when promise settled\n       * @param {CPFinallyHandler} onFinally\n       * @returns {Promise<T | void>}\n       */\n\n    }, {\n      key: \"finally\",\n      value: function _finally(onFinally) {\n        var _this12 = this;\n\n        return this.then(function (value, scope) {\n          return _this12.resolve(onFinally.call(scope, value, false, scope)).then(function () {\n            return value;\n          });\n        }, function (reason, scope) {\n          return _this12.resolve(onFinally.call(scope, reason, true, scope)).then(function () {\n            return _this12.reject(reason);\n          });\n        });\n      }\n      /**\n       * @typedef {function} CPDoneHandler\n       * @param {*} settledValue\n       * @param {boolean} isRejected\n       * @param {CPromise} scope\n       * @this CPromise\n       */\n\n      /**\n       * Add a handler that will be called after the promise has been fulfilled, but unlike `finally`,\n       * the returned plain value will not be ignored\n       * @param {CPDoneHandler} doneHandler\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"done\",\n      value: function done(doneHandler) {\n        return this.then(function (value, scope) {\n          return doneHandler.call(scope, value, false, scope);\n        }, function (err, scope) {\n          return doneHandler.call(scope, err, true, scope);\n        });\n      }\n      /**\n       * Catches CancelError rejection\n       * @param {Function} [onCanceled]\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"canceled\",\n      value: function canceled(onCanceled) {\n        return this.catch(function (err, scope) {\n          if (CanceledError.isCanceledError(err)) {\n            if (onCanceled === undefined) return;\n\n            if (typeof onCanceled !== 'function') {\n              throw TypeError('onCanceled must be a function');\n            }\n\n            return onCanceled(err, scope);\n          }\n\n          throw err;\n        });\n      }\n      /**\n       * Checks if thing is an CanceledError instance\n       * @param thing\n       * @returns {boolean}\n       */\n\n    }, {\n      key: \"listen\",\n\n      /**\n       * Listen for abort signal\n       * @param {AbortSignal} signal\n       * @returns {CPromise}\n       */\n      value: function listen(signal) {\n        var _this13 = this;\n\n        if (!isAbortSignal(signal)) {\n          throw TypeError('signal should implement AbortSignal interface');\n        }\n\n        var signalListener = function signalListener(type, event, reason) {\n          _this13.cancel(reason);\n        };\n\n        signal.addEventListener('abort', signalListener);\n        this.on('done', function () {\n          signal.removeEventListener('abort', signalListener);\n        });\n        return this;\n      }\n      /**\n       * @typedef {object} CPAllOptions\n       * @property {number} [concurrency] limit concurrency of promise being run simultaneously\n       * @property {function} [mapper] function to map each element\n       * @property {boolean} [ignoreResults] do not collect results\n       * @property {boolean} [signatures] use advanced signatures for vales resolving\n       */\n\n      /**\n       * Returns a single CPromise that resolves to an array of the results of the input promises.\n       * If one fails then other promises will be canceled immediately\n       * @param {Iterable|Generator|GeneratorFunction|array} iterable\n       * @param {CPAllOptions} [options]\n       * @returns {CPromise}\n       * @example\n       * CPromise.all(function*(){\n       *     yield axios.get(url1);\n       *     yield axios.get(url2);\n       *     yield axios.get(url3);\n       * }, {concurrency: 1}).then(console.log)\n       */\n\n    }, {\n      key: \"on\",\n\n      /**\n       * adds a new listener\n       * @param {EventType} type\n       * @param {Function} listener\n       * @param {Boolean} [prepend= false]\n       * @returns {CPromise}\n       */\n      value: function on(type, listener, prepend) {\n        var events = this[_events];\n        if (!events) return this;\n        var listeners = events[type];\n        var newListener = events.newListener;\n\n        if (!listeners) {\n          newListener && this.emit('newListener', type, listener);\n          events[type] = listener;\n          return this;\n        }\n\n        if (typeof listeners === 'function') {\n          if (listeners === listener) return this;\n          newListener && this.emit('newListener', type, listener);\n          events[type] = prepend ? [listener, listeners] : [listeners, listener];\n          return this;\n        }\n\n        if (listeners.indexOf(listener) !== -1) return this;\n        newListener && this.emit('newListener', type, listener);\n        prepend ? listeners.unshift(listener) : listeners.push(listener);\n        return this;\n      }\n      /**\n       * Check whether the listener is already registered to the specific event\n       * @param {EventType} event\n       * @param {Function} listener\n       * @returns {boolean}\n       */\n\n    }, {\n      key: \"hasListener\",\n      value: function hasListener(event, listener) {\n        var events = this[_events];\n        if (!events) return false;\n        var listeners = events[event];\n        return !!listeners && (typeof listeners === 'function' || listeners.indexOf(listener) !== -1);\n      }\n      /**\n       * removes the listener\n       * @param {EventType} type\n       * @param {Function} listener\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"off\",\n      value: function off(type, listener) {\n        if (typeof listener !== 'function') {\n          throw TypeError('listener must be a function');\n        }\n\n        var events = this[_events];\n        if (!events) return this;\n        var listeners = events[type];\n\n        if (!listeners) {\n          return this;\n        }\n\n        if (typeof listeners === 'function' && listeners === listener) {\n          events[type] = null;\n          events['removeListener'] && this.emit('removeListener', type, listener);\n          return this;\n        }\n\n        var len = listeners.length;\n\n        for (var i = 0; i < len; i++) {\n          if (listeners[i] === listener) {\n            len === 1 ? events[type] = null : listeners.splice(i, 1);\n            events['removeListener'] && this.emit('removeListener', type, listener);\n            return this;\n          }\n        }\n\n        return this;\n      }\n      /**\n       * returns listeners count of the specific event type\n       * @param {EventType} type\n       * @returns {Number}\n       */\n\n    }, {\n      key: \"listenersCount\",\n      value: function listenersCount(type) {\n        var events = this[_events];\n        if (!events) return 0;\n        var listeners = events[type];\n        if (!listeners) return 0;\n        return typeof listeners === 'function' ? 1 : listeners.length;\n      }\n      /**\n       * checks if there are listeners of a specific type\n       * @param {String|Symbol} type\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"hasListeners\",\n      value: function hasListeners(type) {\n        var events = this[_events];\n        return !!(events && events[type]);\n      }\n      /**\n       * add 'once' listener\n       * @param {EventType} type\n       * @param {Function} listener\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"once\",\n      value: function once(type, listener) {\n        var emitter = this;\n\n        function _listener() {\n          emitter.off(type, _listener);\n          listener.apply(emitter, arguments);\n        }\n\n        return this.on(type, _listener);\n      }\n      /**\n       * emits the event\n       * @param {EventType} type\n       * @param args\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"emit\",\n      value: function emit(type) {\n        var events = this[_events];\n        if (!events) return this;\n        var listeners = events[type];\n        if (!listeners) return this;\n\n        for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n          args[_key8 - 1] = arguments[_key8];\n        }\n\n        if (typeof listeners === 'function') {\n          listeners.apply(this, args);\n          return this;\n        }\n\n        for (var i = 0; i < listeners.length; i++) {\n          listeners[i].apply(this, args);\n        }\n\n        return this;\n      }\n      /**\n       * Emits event as a hook. If some listener return true, this method will immediately return true as the result.\n       * Else false will be retuned\n       * @param {EventType} type\n       * @param args\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"emitHook\",\n      value: function emitHook(type) {\n        var events = this[_events];\n        if (!events) return false;\n        var listeners = events[type];\n        if (!listeners) return false;\n\n        for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n          args[_key9 - 1] = arguments[_key9];\n        }\n\n        if (typeof listeners === 'function') {\n          return !!listeners.apply(this, args);\n        }\n\n        for (var i = 0; i < listeners.length; i++) {\n          if (listeners[i].apply(this, args)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }, {\n      key: \"toString\",\n\n      /**\n       * Render promise to String\n       * @param {boolean} [entireChain= false] render the entire promise chain\n       * @returns {string}\n       */\n      value: function toString(entireChain) {\n        var _this14 = this;\n\n        if (!entireChain) {\n          return _get(_getPrototypeOf(CPromise.prototype), \"toString\", this).call(this);\n        }\n\n        var renderStatus = function renderStatus(scope) {\n          if (scope.isPaused) return 'paused';\n          var shadow = scope[_shadow];\n          if (scope.isPending) return 'pending' + (shadow.computedProgress !== -1 ? \"[\".concat((shadow.computedProgress * 100).toFixed(1), \"%]\") : '');\n          var value = shadow.value;\n          return \"\".concat(scope.isRejected ? 'rejected' : 'resolved').concat(value === undefined ? '' : \"<\".concat(value, \">\"));\n        };\n\n        var renderScope = function renderScope(scope) {\n          if (!(scope instanceof _this14.constructor)) {\n            return scope.constructor.name;\n          }\n\n          var shadow = scope[_shadow];\n          var render = scope[_render];\n          var innerChain = shadow.innerChain,\n              label = shadow.label;\n          var title = label || render && render.call(scope) || getTag(scope.constructor);\n          return innerChain ? \"\".concat(title, \"(\").concat(renderScope(innerChain), \")\") : title;\n        };\n\n        return this.scopes().reverse().map(function (scope) {\n          return \"\".concat(renderScope(scope), \"<\").concat(renderStatus(scope), \">\");\n        }).join(' → ');\n      }\n    }, {\n      key: \"signal\",\n      get: function get() {\n        var shadow = this[_shadow];\n        if (this[_shadow].controller) return this[_shadow].controller.signal;\n        return (this[_shadow].controller = new (shadow.nativeController ? AbortController : AbortControllerEx)()).signal;\n      }\n    }, {\n      key: \"isPending\",\n      get: function get() {\n        return this[_shadow].isPending;\n      }\n      /**\n       * indicates if the promise is pending\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"isCanceled\",\n      get: function get() {\n        return this[_shadow].isCanceled;\n      }\n      /**\n       * indicates if the promise progress is captured\n       * @return {Boolean}\n       */\n\n    }, {\n      key: \"isCaptured\",\n      get: function get() {\n        return this[_shadow].isCaptured;\n      }\n      /**\n       * indicates if the promise chain is paused\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"isPaused\",\n      get: function get() {\n        return this.scopes(true).some(function (scope) {\n          return scope[_shadow].paused;\n        });\n      }\n      /**\n       * indicates if the promise is rejected\n       * @returns {Boolean}\n       */\n\n    }, {\n      key: \"isRejected\",\n      get: function get() {\n        return this[_shadow].isRejected;\n      }\n      /**\n       * get parent promise\n       * @returns {CPromise|null}\n       */\n\n    }, {\n      key: \"parent\",\n      get: function get() {\n        return this[_shadow].parent;\n      }\n    }], [{\n      key: \"isCanceledError\",\n      value: function isCanceledError(thing) {\n        return CanceledError.isCanceledError(thing);\n      }\n      /**\n       * Returns a CPromise that will be resolved after specified timeout\n       * @param {Number} ms - delay before resolve the promise with specified value\n       * @param value\n       * @param {object} [options]\n       * @param {number} [options.progressTick= 1000] progress timer tick, must be >= 100ms\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"delay\",\n      value: function delay(ms, value, options) {\n        return new this(function (resolve, reject, scope) {\n          if (!Number.isFinite(ms)) {\n            throw TypeError('delay must be a finite number');\n          }\n\n          var timer = setTimeout(function () {\n            timer = 0;\n            resolve(value);\n          }, ms);\n\n          scope[_render] = function () {\n            return \"\".concat(getTag(scope.constructor), \".delay(\").concat(ms, \")\");\n          };\n\n          scope.onDone(function () {\n            return timer && clearTimeout(timer);\n          });\n\n          var _ref12 = options !== undefined ? validateOptions(options, {\n            progressTick: numberFinitePositive\n          }) : {},\n              _ref12$progressTick = _ref12.progressTick,\n              progressTick = _ref12$progressTick === void 0 ? 1000 : _ref12$progressTick;\n\n          if (progressTick) {\n            if (progressTick < 100) {\n              throw Error('progressTick must be grater than 100ms to avoid performance impact');\n            }\n\n            var captureProgress = function captureProgress() {\n              if (ms > progressTick * 1.5) {\n                var timestamp = Date.now();\n                var progressTimer = setInterval(function () {\n                  scope.progress((Date.now() - timestamp) / ms);\n                }, progressTick);\n                scope.onDone(function () {\n                  return clearTimeout(progressTimer);\n                });\n              }\n            };\n\n            if (scope.isCaptured) {\n              captureProgress();\n            } else {\n              scope.onCapture(captureProgress);\n            }\n          }\n        });\n      }\n    }, {\n      key: \"all\",\n      value: function all(iterable, options) {\n        var _this15 = this;\n\n        return new this(function (resolve, reject, scope) {\n          var pending;\n          var results;\n          var progressAcc = 0;\n          var isCaptured;\n          var endReached;\n          var generator;\n\n          if (options !== undefined) {\n            validateOptions(options, {\n              concurrency: numberFinitePositive,\n              ignoreResults: boolean,\n              signatures: boolean,\n              mapper: validators.function,\n              args: array()\n            });\n          }\n\n          var _ref13 = options || {},\n              _ref13$concurrency = _ref13.concurrency,\n              concurrency = _ref13$concurrency === void 0 ? 0 : _ref13$concurrency,\n              ignoreResults = _ref13.ignoreResults,\n              signatures = _ref13.signatures,\n              mapper = _ref13.mapper,\n              _ref13$args = _ref13.args,\n              args = _ref13$args === void 0 ? null : _ref13$args;\n\n          var cancel = function cancel(reason) {\n            var _pending = pending,\n                length = _pending.length;\n            var result = false;\n\n            for (var i = 0; i < length; i++) {\n              if (pending[i].cancel(reason)) {\n                result = true;\n              }\n            }\n\n            return result;\n          };\n\n          scope.onCancel(cancel);\n          scope.onPause(function () {\n            var _pending2 = pending,\n                length = _pending2.length;\n\n            for (var i = 0; i < length; i++) {\n              pending[i].pause();\n            }\n          });\n          scope.onResume(function () {\n            var _pending3 = pending,\n                length = _pending3.length;\n\n            for (var i = 0; i < length; i++) {\n              pending[i].resume();\n            }\n          });\n          scope.onSignal(function (type, data) {\n            var _pending4 = pending,\n                length = _pending4.length;\n            var result = false;\n\n            if (type === SIGNAL_CANCEL) {\n              return cancel(data.err, data.force);\n            }\n\n            for (var i = 0; i < length; i++) {\n              if (pending[i].emitSignal(type, data)) {\n                result = true;\n              }\n            }\n\n            return result;\n          });\n\n          var handleProgress = function handleProgress(value, _scope, data) {\n            var total = scope.innerWeight();\n            if (!total) return;\n            var sum = progressAcc;\n            var _pending5 = pending,\n                length = _pending5.length;\n\n            for (var i = 0; i < length; i++) {\n              var promise = pending[i];\n              sum += promise.progress() * promise.weight();\n            }\n\n            sum <= total && scope.progress(sum / total, _scope, data);\n          };\n\n          var _reject = function _reject(err) {\n            reject(err);\n            cancel();\n          };\n\n          function throwConvertError() {\n            throw TypeError('unable to convert object to iterable');\n          }\n\n          scope.on('capture', function () {\n            var i = pending.length;\n\n            while (i-- > 0) {\n              pending[i].progress(handleProgress);\n            }\n\n            isCaptured = true;\n            !scope.innerWeight() && scope.innerWeight(computeWeightSum(pending));\n          });\n\n          if (!concurrency) {\n            pending = toArray(iterable, function (value, i) {\n              return _this15.resolve(mapper ? mapper(value, i) : value, signatures);\n            }) || throwConvertError();\n\n            scope[_render] = function () {\n              return \"\".concat(getTag(scope.constructor), \".all[\").concat(pending.length, \"]\");\n            };\n\n            return _get(_getPrototypeOf(CPromise), \"all\", _this15).call(_this15, pending).then(resolve, _reject);\n          }\n\n          if (isArray(iterable)) {\n            scope[_render] = function () {\n              return \"\".concat(getTag(scope.constructor), \".all[\").concat(iterable.length, \"]\");\n            };\n\n            scope.innerWeight(iterable.length || 1);\n          }\n\n          generator = toGenerator(iterable, args, scope) || throwConvertError();\n          pending = [];\n          !ignoreResults && (results = []);\n\n          var next = function next(value) {\n            var promise = _this15.resolve(value, signatures);\n\n            pending.push(promise);\n            isCaptured && promise.progress(handleProgress);\n            promise.then(function (resolved) {\n              var index = pending.indexOf(promise);\n\n              if (index !== -1) {\n                pending.splice(index, 1);\n              }\n\n              !ignoreResults && results.push(resolved);\n              isCaptured && (progressAcc += promise.weight());\n              !endReached && pump();\n\n              if (!pending.length) {\n                resolve(ignoreResults ? undefined : results);\n              }\n            }, _reject);\n          };\n\n          var pump = function pump() {\n            while (!endReached && pending.length < concurrency) {\n              var item = void 0;\n\n              try {\n                item = generator.next();\n              } catch (err) {\n                _reject(err);\n\n                return;\n              }\n\n              if (item.done) {\n                endReached = true;\n                return;\n              }\n\n              next(mapper ? mapper(item.value) : item.value);\n            }\n          };\n\n          pump();\n        });\n      }\n      /**\n       * returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects,\n       * with the value or reason from that promise. Other pending promises will be canceled immediately\n       * @param {Iterable} pending\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"race\",\n      value: function race(pending) {\n        var _this16 = this;\n\n        return new this(function (resolve, reject, scope) {\n          pending = toArray(pending);\n          var _pending6 = pending,\n              length = _pending6.length;\n\n          scope[_render] = function () {\n            return \"\".concat(getTag(scope.constructor), \".race[\").concat(length, \"]\");\n          };\n\n          for (var i = 0; i < length; i++) {\n            pending[i] = _this16.resolve(pending[i]);\n          }\n\n          var cancel = function cancel(reason) {\n            var result = false;\n\n            for (var _i = 0; _i < length; _i++) {\n              if (pending[_i].cancel(reason)) {\n                result = true;\n              }\n            }\n\n            return result;\n          };\n\n          scope.onCapture(function () {\n            var max = 0;\n\n            for (var _i2 = 0; _i2 < length; _i2++) {\n              pending[_i2].progress(function (value, scope, data) {\n                for (var _i3 = 0; _i3 < length; _i3++) {\n                  if (value > max) {\n                    max = value;\n                    return scope.set(value, data);\n                  }\n                }\n              });\n            }\n          });\n          scope.onCancel(cancel);\n          scope.onPause(function () {\n            for (var _i4 = 0; _i4 < length; _i4++) {\n              pending[_i4].pause();\n            }\n          });\n          scope.onResume(function () {\n            for (var _i5 = 0; _i5 < length; _i5++) {\n              pending[_i5].resume();\n            }\n          });\n          scope.onSignal(function (type, data) {\n            if (type === SIGNAL_CANCEL) {\n              return cancel(data.err, data.force);\n            }\n\n            var result = false;\n\n            for (var _i6 = 0; _i6 < length; _i6++) {\n              if (pending[_i6].emitSignal(type, data)) {\n                result = true;\n              }\n            }\n\n            return result;\n          });\n\n          _get(_getPrototypeOf(CPromise), \"race\", _this16).call(_this16, pending).then(function (value) {\n            resolve(value);\n            cancel();\n          }, function (err) {\n            reject(err);\n            cancel();\n          });\n        });\n      }\n      /**\n       * returns a promise that resolves after all of the given promises have either fulfilled or rejected\n       * @param {Iterable|Generator|GeneratorFunction} iterable\n       * @param {CPAllOptions} [options]\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"allSettled\",\n      value: function allSettled(iterable, options) {\n        var _this17 = this;\n\n        var _ref14 = options || {},\n            _mapper = _ref14.mapper,\n            allOptions = _objectWithoutProperties(_ref14, [\"mapper\"]);\n\n        var promise = this.all(iterable, _objectSpread(_objectSpread({}, allOptions), {}, {\n          mapper: function mapper(value, i) {\n            return _this17.resolve(_mapper ? _mapper(value, i) : value).then(function (value) {\n              return {\n                status: \"fulfilled\",\n                value: value\n              };\n            }, function (err) {\n              if (CanceledError.isCanceledError(err)) {\n                throw err;\n              }\n\n              return {\n                status: \"rejected\",\n                reason: err\n              };\n            });\n          }\n        }));\n\n        promise[_render] = function () {\n          return \"\".concat(getTag(scope.constructor), \".allSettled\");\n        };\n\n        return promise;\n      }\n      /**\n       * @typedef {function} CPRetryFunction\n       * @param {number} attempt\n       * @param {array} args\n       * @returns {*}\n       */\n\n      /**\n       * @typedef {GeneratorFunction} CPGeneratorRetryFunction\n       * @param {CPromise} scope\n       * @param {number} attempt\n       * @param {array} args\n       * @returns {*}\n       */\n\n      /**\n       * @typedef {function} CPRetryDelayResolver\n       * @param {number} attempt\n       * @param {number} retries\n       * @returns {number} a delay in ms before next attempt\n       */\n\n      /**\n       * Retry async operation\n       * @param {CPGeneratorRetryFunction|CPRetryFunction} fn\n       * @param {Object} [options]\n       * @param {Array} [options.args]\n       * @param {Number} [options.retries]\n       * @param {Number} [options.delayWeight]\n       * @param {Number|CPRetryDelayResolver} [options.delay]\n       * @param {Boolean} [options.scopeArg= false]\n       * @return {CPromise}\n       */\n\n    }, {\n      key: \"retry\",\n      value: function retry(fn, options) {\n        var _this18 = this;\n\n        if (typeof fn !== 'function') {\n          throw TypeError('fn must be a function');\n        }\n\n        options !== undefined && validateOptions(options, {\n          args: array(),\n          retries: numberFinitePositive,\n          delayWeight: numberFinitePositive,\n          delay: union(numberFinitePositive, functionPlain),\n          scopeArg: boolean\n        });\n\n        var _ref15 = typeof options === 'number' ? {\n          retries: options\n        } : options || {},\n            _ref15$args = _ref15.args,\n            args = _ref15$args === void 0 ? [] : _ref15$args,\n            _ref15$retries = _ref15.retries,\n            retries = _ref15$retries === void 0 ? 3 : _ref15$retries,\n            _ref15$delayWeight = _ref15.delayWeight,\n            delayWeight = _ref15$delayWeight === void 0 ? 0.1 : _ref15$delayWeight,\n            _ref15$delay = _ref15.delay,\n            delay = _ref15$delay === void 0 ? function (attempt) {\n          return attempt * 1000;\n        } : _ref15$delay,\n            _ref15$scopeArg = _ref15.scopeArg,\n            scopeArg = _ref15$scopeArg === void 0 ? false : _ref15$scopeArg;\n\n        var attemptIndex = 0;\n        return new this(function (resolve, reject, scope) {\n          var shadow = scope[_shadow];\n\n          var attempt = function attempt() {\n            var fnArgs = [attemptIndex, args];\n\n            var doAttempt = function doAttempt() {\n              return isGeneratorFunction(fn) ? _this18.run(fn, {\n                args: fnArgs,\n                scopeArg: scopeArg\n              }) : new _this18(function (resolve, reject, _scope) {\n                resolve(fn.apply(_scope, scopeArg ? [_scope, attemptIndex, args] : fnArgs));\n              });\n            };\n\n            var _delay = delay;\n\n            if (attemptIndex && typeof delay === 'function') {\n              _delay = delay(attemptIndex, retries);\n\n              if (!numberFinitePositive(_delay)) {\n                throw TypeError(\"delay fn must return a finite number\");\n              }\n            }\n\n            scope[_render] = function () {\n              return \"\".concat(getTag(scope.constructor), \".try[\").concat(attemptIndex, \"/\").concat(retries, \"]\");\n            };\n\n            scope.progress(0);\n            var promise = (attemptIndex && _delay ? _this18.delay(_delay).weight(delayWeight).then(doAttempt) : doAttempt()).weight(0.9).then(resolve, function (err) {\n              if (!CanceledError.isCanceledError(err, E_REASON_CANCELED, E_REASON_DISPOSED, E_REASON_UNMOUNTED)) {\n                if (++attemptIndex < retries || !retries) {\n                  setImmediate$1(attempt);\n                  return;\n                }\n              }\n\n              reject(err);\n            }).weight(0);\n\n            if (shadow.innerChain) {\n              shadow.innerChain[_events] = null;\n            }\n\n            scope[_setInnerChain](promise);\n\n            return promise;\n          };\n\n          attempt();\n        });\n      }\n      /**\n       * @typedef {Object} resolveOptionsObject\n       * @property {Boolean} [resolveSignatures= true]\n       * @property {AtomicType} [atomic= true]\n       * @property {*} [args]\n       */\n\n      /**\n       * Converts thing to CPromise using the following rules:\n       * - CPromise instance returns as is\n       * - Objects with special method defined with key `Symbol.for('toCPromise')` will be converted using this method\n       *   The result will be cached for future calls\n       * - Thenable wraps into a new CPromise instance, if thenable has the `cancel` method it will be used for canceling\n       * - Generator function will be resolved to CPromise\n       * - Array will be resoled via `CPromise.all`, arrays with one element (e.g. `[[1000]]`) will be resolved via `CPromise.race`\n       *\n       * This method returns null if the conversion failed.\n       * @param {*} [thing]\n       * @param {resolveOptionsObject|Boolean} [options]\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"resolve\",\n      value: function resolve(thing, options) {\n        var _this19 = this;\n\n        if (!thing) {\n          return _get(_getPrototypeOf(CPromise), \"resolve\", this).call(this, thing);\n        }\n\n        if (thing instanceof this) {\n          return thing;\n        }\n\n        var _ref16 = (typeof options === 'boolean' ? {\n          resolveSignatures: options\n        } : options) || {},\n            _ref16$resolveSignatu = _ref16.resolveSignatures,\n            resolveSignatures = _ref16$resolveSignatu === void 0 ? true : _ref16$resolveSignatu,\n            _ref16$atomic = _ref16.atomic,\n            atomic = _ref16$atomic === void 0 ? true : _ref16$atomic;\n\n        var type = typeof thing;\n\n        if (type === 'object') {\n          if (resolveSignatures && isArray(thing)) {\n            if (thing.length === 1) {\n              var first = thing[0];\n\n              if (isArray(first)) {\n                return this.race(first.map(function (thing) {\n                  return _this19.resolve(thing, options);\n                }));\n              }\n            }\n\n            return this.all(thing.map(function (thing) {\n              return _this19.resolve(thing, options);\n            }));\n          }\n\n          var convertMethod = thing[_toCPromise];\n\n          if (typeof convertMethod === 'function') {\n            var returnedValue = convertMethod.call(thing, this);\n\n            if (!this.isCPromise(returnedValue)) {\n              this.reject(new Error(\"method '\".concat(_toCPromise, \"()' must return a CPromise instance\")));\n            }\n\n            return returnedValue;\n          }\n\n          if (typeof thing.then === 'function') {\n            var hasCanceler = typeof thing.cancel === 'function';\n            var promise = new this(function (resolve, reject, _ref17) {\n              var onCancel = _ref17.onCancel;\n\n              if (hasCanceler) {\n                onCancel(function (reason) {\n                  try {\n                    thing.cancel(reason);\n                  } catch (err) {\n                    reject(err);\n                  }\n                });\n              }\n\n              return thing.then(resolve, reject);\n            });\n            return hasCanceler ? promise : promise.atomic(atomic);\n          }\n        } else if (resolveSignatures && isGeneratorFunction(thing)) {\n          return this.run(thing);\n        }\n\n        return _get(_getPrototypeOf(CPromise), \"resolve\", this).call(this, thing);\n      }\n      /**\n       * @typedef {Function} PromisifyFinalizeFn\n       * @param {*} result\n       * @param {CPromise} scope\n       */\n\n      /**\n       * @typedef {function} CPPromisifyDecoratorFn\n       * @param {function} originalFn function to decorate\n       * @param {PromisifyOptions} options\n       * @returns {function}\n       */\n\n      /**\n       * @typedef {Object} PromisifyOptions\n       * @property {Boolean} [multiArgs] aggregate all passed arguments to an array\n       * @property {PromisifyFinalizeFn} [finalize] aggregate all passed arguments to an array\n       * @property {\"plain\"|\"generator\"|\"async\"} [fnType]\n       * @property {boolean} [scopeArg] pass the CPromise scope as the first argument to the generator function\n       * @property {function} [decorator] CPPromisifyDecoratorFn\n       * @property {boolean} [alignArgs] align passed arguments to function definition for callback-styled function\n       * @property {boolean} [once= true] don't promisify already promisified function\n       * @property {array<'plain'|'async'|'generator'>} [types] function types to promisify\n       */\n\n      /**\n       * Converts callback styled function|GeneratorFn|AsyncFn to CPromise async function\n       * @param {Function|GeneratorFunction|AsyncFunction} originalFn\n       * @param {PromisifyOptions|Function|Boolean} [options]\n       * @returns {function(...[*]): CPromise}\n       */\n\n    }, {\n      key: \"promisify\",\n      value: function promisify(originalFn, options) {\n        var type = typeof options;\n\n        if (type === 'boolean') {\n          options = {\n            multiArgs: !!options\n          };\n        } else if (type === 'function') {\n          options = {\n            finalize: options\n          };\n        } else {\n          options !== undefined && validateOptions(options, {\n            multiArgs: boolean,\n            finalize: functionPlain,\n            fnType: string,\n            scopeArg: boolean,\n            decorator: functionPlain,\n            alignArgs: boolean,\n            once: boolean,\n            types: array(validators.values('plain', 'async', 'generator'))\n          });\n        }\n\n        var _ref18 = options || {},\n            multiArgs = _ref18.multiArgs,\n            finalize = _ref18.finalize,\n            _ref18$fnType = _ref18.fnType,\n            fnType = _ref18$fnType === void 0 ? getFnType(originalFn) : _ref18$fnType,\n            scopeArg = _ref18.scopeArg,\n            decorator = _ref18.decorator,\n            _ref18$alignArgs = _ref18.alignArgs,\n            alignArgs = _ref18$alignArgs === void 0 ? true : _ref18$alignArgs,\n            _ref18$once = _ref18.once,\n            once = _ref18$once === void 0 ? true : _ref18$once,\n            types = _ref18.types;\n\n        var context = this;\n\n        if (once && originalFn[_promisified]) {\n          return originalFn;\n        }\n\n        if (types && types.indexOf(fnType) === -1) return originalFn;\n        var decoratedFn = decorator && decorator.call(context, originalFn, _objectSpread(_objectSpread({}, options), {}, {\n          fnType: fnType\n        })) || originalFn;\n\n        var fn = function () {\n          switch (fnType) {\n            case \"plain\":\n              return function () {\n                var _this20 = this;\n\n                for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n                  args[_key10] = arguments[_key10];\n                }\n\n                return new context(function (resolve, reject, scope) {\n                  var callback = function callback(err) {\n                    if (err) {\n                      return reject(err);\n                    }\n\n                    for (var _len11 = arguments.length, data = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n                      data[_key11 - 1] = arguments[_key11];\n                    }\n\n                    return multiArgs || data.length > 1 ? resolve(data) : resolve(data[0]);\n                  };\n\n                  if (alignArgs) {\n                    var min = originalFn.length - 1;\n\n                    if (args.length < min) {\n                      args.length = min;\n                    }\n                  }\n\n                  var result = decoratedFn.apply(_this20, scopeArg ? [scope].concat(args, [callback]) : [].concat(args, [callback]));\n                  finalize && finalize(result, scope);\n\n                  if (isThenable(result)) {\n                    result.then(resolve, reject);\n                  } else if (!decoratedFn.length) {\n                    resolve(result);\n                  }\n                });\n              };\n\n            case \"generator\":\n              return function () {\n                for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n                  args[_key12] = arguments[_key12];\n                }\n\n                return context.run(decoratedFn, {\n                  context: isContextDefined(this) ? this : null,\n                  scopeArg: scopeArg,\n                  args: args\n                });\n              };\n\n            case \"async\":\n              return function () {\n                var _this21 = this;\n\n                for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n                  args[_key13] = arguments[_key13];\n                }\n\n                return new context(function (resolve, reject, scope) {\n                  decoratedFn.apply(isContextDefined(_this21) ? _this21 : scope, scopeArg ? [scope].concat(args) : args).then(resolve, reject);\n                }).atomic();\n              };\n          }\n\n          throw TypeError('promisify requires a Function|GeneratorFunction|AsyncFunction as the first argument');\n        }();\n\n        fn[_promisified] = fnType;\n        return fn;\n      }\n      /**\n       * Resolves the generator to an CPromise instance\n       * @param {GeneratorFunction} generatorFn\n       * @param {Object} [options]\n       * @param {Array} [options.args]\n       * @param {Boolean} [options.resolveSignatures] resolve extra signatures (like arrays with CPromise.all)\n       * @param {Boolean} [options.scopeArg] pass the CPromise scope as the first argument to the generator function\n       * @param {*} [options.context]\n       * @returns {CPromise}\n       */\n\n    }, {\n      key: \"run\",\n      value: function run(generatorFn) {\n        var _this22 = this;\n\n        var _ref19 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n            args = _ref19.args,\n            resolveSignatures = _ref19.resolveSignatures,\n            context = _ref19.context,\n            _ref19$scopeArg = _ref19.scopeArg,\n            scopeArg = _ref19$scopeArg === void 0 ? false : _ref19$scopeArg;\n\n        return new this(function (resolve, reject, scope) {\n          var generator;\n          var name = generatorFn && generatorFn.name;\n\n          scope[_render] = function () {\n            return \"\".concat(getTag(scope.constructor), \".run\").concat(name ? '(' + name + '*)' : '');\n          };\n\n          if (!context) {\n            context = scope;\n          }\n\n          if (!scopeArg) {\n            generator = generatorFn.apply(context, args);\n          } else {\n            switch (args ? args.length : 0) {\n              case 0:\n                generator = generatorFn.call(context, scope);\n                break;\n\n              case 1:\n                generator = generatorFn.call(context, scope, args[0]);\n                break;\n\n              case 2:\n                generator = generatorFn.call(context, scope, args[0], args[1]);\n                break;\n\n              default:\n                generator = generatorFn.apply(context, [scope].concat(_toConsumableArray(args)));\n            }\n          }\n\n          if (!isGenerator(generator)) {\n            return reject(new TypeError('function must a generator'));\n          }\n\n          var progress = 0;\n          var sum = 0;\n          var weight = 0;\n          var promise;\n\n          var setProgress = function setProgress(value, _scope, data) {\n            var innerWeight = scope.innerWeight();\n\n            if (innerWeight) {\n              progress = (value * weight + sum) / innerWeight;\n              scope.progress(progress, _scope, data);\n            }\n          };\n\n          var onFulfilled = function onFulfilled(result) {\n            if (scope[_shadow].isCanceled) return;\n\n            try {\n              next(generator.next(result));\n            } catch (e) {\n              return reject(e);\n            }\n          };\n\n          var onRejected = function onRejected(err) {\n            if (scope[_shadow].isCanceled) return;\n\n            try {\n              next(generator.throw(err));\n            } catch (e) {\n              reject(e);\n            }\n          };\n\n          var captureProgress = function captureProgress() {\n            promise.progress(setProgress);\n          };\n\n          !scope.isCaptured && scope.onCapture(function () {\n            promise && captureProgress();\n          });\n\n          var next = function next(r) {\n            if (r.done) {\n              return resolve(r.value);\n            }\n\n            promise = _this22.resolve(r.value, {\n              resolveSignatures: resolveSignatures\n            });\n\n            scope[_setInnerChain](promise, false);\n\n            sum += weight;\n            weight = promise.isChain ? 1 : promise.weight();\n            scope.isCaptured && captureProgress();\n            return promise.then(onFulfilled, onRejected);\n          };\n\n          onFulfilled();\n        });\n      }\n      /**\n       * Decorator to make CPromise async function from generator, ECMA async or callback-styled method\n       * @param {object} [options]\n       * @param {number} [options.timeout]\n       * @param {string} [options.label]\n       * @param {number} [options.innerWeight]\n       * @param {number} [options.weight]\n       * @param {AbortControllerId|AbortController|AbortSignal|Array<AbortControllerId|AbortController|AbortSignal>} [options.listen]\n       * @param {AtomicType} [options.atomic]\n       */\n\n    }, {\n      key: \"async\",\n      value: function async(options) {}\n      /**\n       * @typedef {string|symbol} AbortControllerId\n       */\n\n      /**\n       * Decorator to subscribe CPromise async method to the internal or external controller\n       * @param {AbortControllerId|AbortController|AbortSignal|Array<AbortControllerId|AbortController|AbortSignal>} [signals]\n       */\n\n    }, {\n      key: \"listen\",\n      value: function listen(signals) {}\n      /**\n       * Decorator to cancel internal or external abort controller before the decorated function invocation.\n       * Can be used as a plain function by passing a object context with `.call` or `.apply` methods\n       * @param {string} [reason]\n       * @param {AbortControllerId|AbortController} signal\n       * @example\n       * el.onclick= ()=> cancel.call(this, reason, 'myControllerId'); - to use the decorator as a plain function\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel(reason, signal) {}\n      /**\n       * Decorator to add an `onCanceled` rejection handler to the resulting promise of the decorated method\n       * @param {function|GeneratorFunction} onCanceledChain\n       */\n\n    }, {\n      key: \"canceled\",\n      value: function canceled(onCanceledChain) {}\n      /**\n       * @typedef {function} ProgressDecoratorHandler\n       * @param {number} progress\n       * @param {CPromise} scope\n       * @param {*} data\n       * @param {object} context\n       */\n\n      /**\n       * Decorator to subscribe the handler to the `onProgress` event of the resulting promise\n       * @param {ProgressDecoratorHandler} onProgressHandler\n       */\n\n    }, {\n      key: \"progress\",\n      value: function progress(onProgressHandler) {}\n      /**\n       * @typedef {object} ReactComponentDecoratorOptions\n       * @property {boolean} [subscribeAll= false]\n       * @property {boolean} [bindListeners= true]\n       * @property {boolean} [bindMethods= true]\n       */\n\n      /**\n       * Decorate class as React component\n       * @param {boolean|ReactComponentDecoratorOptions} options\n       */\n\n    }, {\n      key: \"ReactComponent\",\n      value: function ReactComponent(options) {}\n      /**\n       * Decorator to set timeout for the resulting promise of the decorated function\n       * @param {number} ms\n       */\n\n    }, {\n      key: \"timeout\",\n      value: function timeout(ms) {}\n      /**\n       * Decorator to set label for the resulting promise of the decorated function\n       * @param {string} str\n       */\n\n    }, {\n      key: \"label\",\n      value: function label(str) {}\n      /**\n       * Decorator to set innerWeight for the resulting promise of the decorated function\n       * @param {number} weight\n       */\n\n    }, {\n      key: \"innerWeight\",\n      value: function innerWeight(weight) {}\n      /**\n       * Decorator to set timeout for the resulting promise of the decorated function\n       * @param {AtomicType} atomicType\n       */\n\n    }, {\n      key: \"atomic\",\n      value: function atomic(atomicType) {}\n      /**\n       * @typedef {function} CPDecoratorDoneHandler\n       * @param {*} value\n       * @param {boolean} isRejected\n       * @param {CPromise} scope\n       * @param {object} context\n       */\n\n      /**\n       *  append `done` chain to the resulting promise of the decorated method\n       * @param {CPDecoratorDoneHandler} doneHandler\n       */\n\n    }, {\n      key: \"done\",\n      value: function done(doneHandler) {}\n      /**\n       * Returns promisification strategy that was used to the original function\n       * @param {function} fn\n       * @returns {*|boolean}\n       */\n\n    }, {\n      key: \"isPromisifiedFn\",\n      value: function isPromisifiedFn(fn) {\n        return fn[_promisified] || false;\n      }\n      /**\n       * CPromise version string\n       * @returns {string}\n       */\n\n    }, {\n      key: \"isCPromise\",\n\n      /**\n       * Check whether object is CPromise instance\n       * @param {*} thing\n       * @param {boolean} [anyVersion= false]\n       * @returns {boolean}\n       */\n      value: function isCPromise(thing, anyVersion) {\n        if (thing instanceof this) return true;\n\n        if (this[_isCPromise]) {\n          warnVersionInteraction(thing);\n          return !!anyVersion;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"version\",\n      get: function get() {\n        return this.prototype[_version];\n      }\n      /**\n       * CPromise version number\n       * @returns {number}\n       */\n\n    }, {\n      key: \"versionNumber\",\n      get: function get() {\n        return this.prototype[_versionNumber];\n      }\n    }, {\n      key: toStringTag,\n      get: function get() {\n        return 'CPromise';\n      }\n    }]);\n\n    return CPromise;\n  }( /*#__PURE__*/_wrapNativeSuper(Promise));\n\n  var prototype = CPromise$1.prototype;\n  prototype.addEventListener = prototype.on;\n  prototype.removeEventListener = prototype.off;\n  lazyBindMethods(prototype, ['Cancel', 'Pause', 'Resume', 'Capture', 'Done'].map(function (type) {\n    var typeL = type.toLowerCase();\n    var methodName = 'on' + type;\n\n    prototype[methodName] = function method(listener) {\n      return this.on(typeL, listener);\n    };\n\n    return methodName;\n  }));\n  lazyBindMethods(CPromise$1, Object.getOwnPropertyNames(CPromise$1).map(function (prop) {\n    var _Object$getOwnPropert2 = Object.getOwnPropertyDescriptor(CPromise$1, prop),\n        value = _Object$getOwnPropert2.value;\n\n    return typeof value === 'function' ? prop : '';\n  }).filter(Boolean));\n  Object.defineProperties(CPromise$1, Object.entries({\n    CPromise: CPromise$1,\n    CanceledError: CanceledError,\n    AbortController: AbortController,\n    AbortControllerEx: AbortControllerEx,\n    SIGNAL_CANCEL: SIGNAL_CANCEL,\n    SIGNAL_PAUSE: SIGNAL_PAUSE,\n    SIGNAL_RESUME: SIGNAL_RESUME,\n    E_REASON_CANCELED: E_REASON_CANCELED,\n    E_REASON_TIMEOUT: E_REASON_TIMEOUT,\n    E_REASON_DISPOSED: E_REASON_DISPOSED,\n    E_REASON_UNMOUNTED: E_REASON_UNMOUNTED,\n    ATOMIC_TYPE_DISABLED: ATOMIC_TYPE_DISABLED,\n    ATOMIC_TYPE_DETACHED: ATOMIC_TYPE_DETACHED,\n    ATOMIC_TYPE_AWAIT: ATOMIC_TYPE_AWAIT\n  }).reduce(function (descriptors, _ref20) {\n    var _ref21 = _slicedToArray(_ref20, 2),\n        prop = _ref21[0],\n        value = _ref21[1];\n\n    descriptors[prop] = {\n      value: value,\n      configurable: true\n    };\n    return descriptors;\n  }, {}));\n  Object.entries(Object.getOwnPropertyDescriptors(prototype)).forEach(function (_ref22) {\n    var _ref23 = _slicedToArray(_ref22, 2),\n        prop = _ref23[0],\n        descriptor = _ref23[1];\n\n    if (descriptor.get && descriptor.set === undefined) {\n      descriptor.set = function () {\n        throw Error(\"Can not rewrite read-only public property '\".concat(prop, \"'\"));\n      };\n\n      Object.defineProperty(prototype, prop, descriptor);\n    }\n  });\n\n  var getContextController = function getContextController(context, id, create) {\n    if (typeof id === 'string' || typeof id === 'symbol') {\n      var list = controllersStore.get(context);\n\n      if (!list) {\n        controllersStore.set(context, list = {});\n      }\n\n      var controller = list && list[id || ''];\n      return controller || (create ? list[id] = new AbortControllerEx(true) : null);\n    }\n\n    return isAbortController(id) ? id : null;\n  };\n\n  var ensureContextSignal = function ensureContextSignal(context, id, create) {\n    if (isAbortSignal(id)) return id;\n    var controller = getContextController(context, id, create);\n\n    if (!controller) {\n      throw TypeError(\"required AbortController|AbortSignal|string id|symbol id)\");\n    }\n\n    return controller.signal;\n  };\n\n  var listenSignals = function listenSignals(promise, context, signals) {\n    isArray(signals) ? signals.forEach(function (id) {\n      return promise.listen(ensureContextSignal(context, id, true));\n    }) : promise.listen(ensureContextSignal(context, signals, true));\n  };\n\n  var cancelContext = function cancelContext(context, id, reason) {\n    var controller = getContextController(context, id, false);\n\n    if (controller) {\n      controller && controller.abort(reason);\n      return true;\n    }\n\n    return false;\n  };\n\n  var inheritFnSignature = function inheritFnSignature(target, fn) {\n    target[_promisified] = fn[_promisified];\n    return target;\n  };\n\n  var eventHandlerRE = /^on[A-Z]/;\n  var reactProtoMethods = {\n    componentDidMount: true,\n    shouldComponentUpdate: true,\n    componentWillUnmount: true,\n    getSnapshotBeforeUpdate: true,\n    componentDidUpdate: true,\n    componentDidCatch: true,\n    componentWillReceiveProps: true\n  };\n  var decorators = {\n    async: propertyDecorator(function (decorator, _ref24, _ref25) {\n      var _ref26 = _slicedToArray(_ref24, 1),\n          options = _ref26[0];\n\n      var context = _ref25.context;\n\n      if (typeof options === 'number') {\n        options = {\n          timeout: options\n        };\n      } else if (typeof options === 'string') {\n        options = {\n          label: options\n        };\n      }\n\n      var _ref27 = options || {},\n          timeout = _ref27.timeout,\n          label = _ref27.label,\n          innerWeight = _ref27.innerWeight,\n          weight = _ref27.weight,\n          listen = _ref27.listen,\n          _ref27$scopeArg = _ref27.scopeArg,\n          scopeArg = _ref27$scopeArg === void 0 ? false : _ref27$scopeArg,\n          atomic = _ref27.atomic;\n\n      var fn = context.promisify(decorator.descriptor.value, {\n        scopeArg: scopeArg\n      });\n      decorator.descriptor = {\n        value: inheritFnSignature(function () {\n          var promise = fn.apply(this, arguments);\n          timeout && promise.timeout(timeout);\n          label && promise.label(label);\n          innerWeight && promise.innerWeight(innerWeight);\n          weight && promise.weight(weight);\n          listen && listenSignals(promise, this, listen);\n          atomic !== undefined && promise.atomic(atomic);\n          return promise;\n        }, fn),\n        enumerable: true,\n        configurable: true\n      };\n      return decorator;\n    }, [union(validators.undefined, number, string, object({\n      timeout: number,\n      label: string,\n      innerWeight: number,\n      weight: number,\n      listen: validators.union(string, symbol, array(string, symbol)),\n      scopeArg: boolean,\n      atomic: union(undefined, boolean, validators.values(ATOMIC_TYPE_DISABLED, ATOMIC_TYPE_DETACHED, ATOMIC_TYPE_AWAIT, 'detached', 'disabled', 'await'))\n    }))]),\n    listen: propertyDecorator(function (decorator, _ref28, _ref29) {\n      var _ref30 = _slicedToArray(_ref28, 1),\n          _ref30$ = _ref30[0],\n          signals = _ref30$ === void 0 ? '' : _ref30$;\n\n      var context = _ref29.context;\n      var fn = context.promisify(decorator.descriptor.value);\n      decorator.descriptor = {\n        value: inheritFnSignature(function () {\n          var promise = fn.apply(this, arguments);\n          listenSignals(promise, this, signals);\n          return promise;\n        }, fn),\n        enumerable: true,\n        configurable: true\n      };\n      return decorator;\n    }, [rest(validators.undefined, validators.abortController, validators.abortSignal, string, symbol)]),\n    cancel: propertyDecorator(function (decorator, _ref31) {\n      var _ref32 = _slicedToArray(_ref31, 2),\n          reason = _ref32[0],\n          _ref32$ = _ref32[1],\n          signal = _ref32$ === void 0 ? '' : _ref32$;\n\n      var fn = decorator.descriptor.value;\n      decorator.descriptor.value = inheritFnSignature(function () {\n        cancelContext(this, signal, reason || '');\n        return fn.apply(this, arguments);\n      }, fn);\n      return decorator;\n    }, [union(nullable, string), union(validators.undefined, validators.abortController, string, symbol)], function (reason) {\n      var signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      return cancelContext(this, signal, reason || '');\n    }),\n    canceled: propertyDecorator(function (decorator, _ref33, _ref34) {\n      var _ref35 = _slicedToArray(_ref33, 1),\n          canceledHandler = _ref35[0];\n\n      var context = _ref34.context;\n      var fn = context.promisify(decorator.descriptor.value);\n      var handler = canceledHandler && context.promisify(canceledHandler, {\n        types: ['generator']\n      });\n      decorator.descriptor.value = inheritFnSignature(function () {\n        var _this23 = this;\n\n        return fn.apply(this, arguments).canceled(handler ? function (err, scope) {\n          return handler.call(_this23, err, scope, _this23);\n        } : noop);\n      }, fn);\n      return decorator;\n    }, [union(validators.nullable, validators.function)]),\n    done: propertyDecorator(function (decorator, _ref36, _ref37) {\n      var _ref38 = _slicedToArray(_ref36, 1),\n          doneHandler = _ref38[0];\n\n      var context = _ref37.context;\n      var fn = context.promisify(decorator.descriptor.value);\n      var handler = doneHandler && context.promisify(doneHandler, {\n        types: ['generator']\n      });\n      decorator.descriptor.value = inheritFnSignature(function () {\n        var _this24 = this;\n\n        return fn.apply(this, arguments).done(handler ? function (err, isRejected, scope) {\n          return handler.call(_this24, err, isRejected, scope, _this24);\n        } : noop);\n      }, fn);\n      return decorator;\n    }, [union(validators.nullable, validators.function), union(validators.nullable, boolean, string)]),\n    progress: propertyDecorator(function (decorator, _ref39, _ref40) {\n      var _ref41 = _slicedToArray(_ref39, 1),\n          progressHandler = _ref41[0];\n\n      var context = _ref40.context;\n      var fn = context.promisify(decorator.descriptor.value);\n      decorator.descriptor.value = inheritFnSignature(function () {\n        var _this25 = this;\n\n        return fn.apply(this, arguments).progress(function (value, scope, data) {\n          return progressHandler.call(_this25, value, scope, data, _this25);\n        });\n      }, fn);\n      return decorator;\n    }, [validators.function]),\n    ReactComponent: classDecorator(function (descriptor, options, _ref42) {\n      var context = _ref42.context;\n\n      var _ref43 = (options === false ? {\n        subscribeAll: false,\n        bindMethods: false,\n        bindListeners: false\n      } : options === true ? {\n        subscribeAll: true\n      } : options) || {},\n          subscribeAll = _ref43.subscribeAll,\n          _ref43$bindMethods = _ref43.bindMethods,\n          bindMethods = _ref43$bindMethods === void 0 ? true : _ref43$bindMethods,\n          _ref43$bindListeners = _ref43.bindListeners,\n          bindListeners = _ref43$bindListeners === void 0 ? true : _ref43$bindListeners;\n\n      var descriptors = {};\n      var bindAll = bindMethods && bindListeners;\n      var bind = bindMethods || bindListeners;\n      return {\n        kind: 'class',\n        finisher: function finisher(constructor) {\n          var prototype = constructor.prototype;\n\n          var decorate = function decorate(prop, method) {\n            var originalMethod = method;\n            var isComponentWillUnmount = prop === 'componentWillUnmount';\n            var isComponentDidMount = prop === 'componentDidMount';\n\n            var decorateAsyncMethod = function decorateAsyncMethod(method) {\n              if (isComponentWillUnmount) {\n                return function () {\n                  cancelContext(this, '', E_REASON_UNMOUNTED);\n                  return method.apply(this, arguments);\n                };\n              } else if (subscribeAll || isComponentDidMount) {\n                return function () {\n                  return method.apply(this, arguments).listen(ensureContextSignal(this, '', true));\n                };\n              }\n\n              return method;\n            };\n\n            var bindLazily = function bindLazily(method) {\n              descriptors[prop] = {\n                get: function get() {\n                  var context = this;\n                  return function lazilyBoundListener() {\n                    return method.apply(isContextDefined(this) ? this : context || this, arguments);\n                  };\n                },\n                configurable: true\n              };\n            };\n\n            if (isGeneratorFunction(method)) {\n              method = decorateAsyncMethod(context.promisify(method, {\n                scopeArg: isComponentDidMount || isComponentWillUnmount\n              }));\n            } else if (context.isPromisifiedFn(method)) {\n              method = decorateAsyncMethod(method);\n            }\n\n            if (bind && !reactProtoMethods[prop] && (bindAll || (eventHandlerRE.test(prop) ? bindListeners : bindMethods))) {\n              bindLazily(method);\n              return;\n            }\n\n            if (method !== originalMethod) {\n              descriptors[prop] = {\n                value: method,\n                configurable: true\n              };\n            }\n          };\n\n          Object.getOwnPropertyNames(prototype).forEach(function (prop) {\n            if (prop === 'constructor' || prop === 'render') return;\n            var value = prototype[prop];\n            if (typeof value !== 'function') return;\n            decorate(prop, value);\n          });\n\n          if (!('componentWillUnmount' in prototype)) {\n            descriptors.componentWillUnmount = {\n              value: function value() {\n                cancelContext(this, '', E_REASON_UNMOUNTED);\n              },\n              configurable: true\n            };\n          }\n\n          Object.defineProperties(prototype, descriptors);\n          return constructor;\n        }\n      };\n    }, [union(validators.undefined, boolean, object({\n      subscribeAll: boolean,\n      bindMethods: boolean,\n      bindListeners: boolean\n    }))])\n  };\n  Object.entries({\n    'timeout': number,\n    'label': string,\n    'innerWeight': number,\n    'atomic': [validators.undefined, boolean, validators.values(ATOMIC_TYPE_DISABLED, ATOMIC_TYPE_DETACHED, ATOMIC_TYPE_AWAIT, 'detached', 'disabled', 'await')]\n  }).forEach(function (_ref44) {\n    var _ref45 = _slicedToArray(_ref44, 2),\n        name = _ref45[0],\n        type = _ref45[1];\n\n    decorators[name] = propertyDecorator(function (decorator, _ref46, _ref47) {\n      var _ref48 = _slicedToArray(_ref46, 1),\n          value = _ref48[0];\n\n      var context = _ref47.context;\n      var fn = context.promisify(decorator.descriptor.value);\n      var isFunction = typeof value === 'function';\n      decorator.descriptor.value = inheritFnSignature(function () {\n        var promise = fn.apply(this, arguments);\n        return promise[name](isFunction ? value.call(this, this) : value);\n      }, fn);\n      return decorator;\n    }, [isArray(type) ? union.apply(void 0, [validators.function].concat(_toConsumableArray(type))) : union(type, validators.function)]);\n  });\n  bindDecorators(CPromise$1, decorators);\n  Object.defineProperties(prototype, (_Object$definePropert3 = {}, _defineProperty(_Object$definePropert3, _isCPromise, {\n    value: true\n  }), _defineProperty(_Object$definePropert3, _version, {\n    value: version\n  }), _defineProperty(_Object$definePropert3, _versionNumber, {\n    value: versionNumber\n  }), _Object$definePropert3));\n  var CPromise_1 = CPromise$1;\n  /**\n   * CanceledError class\n   * @type {CanceledError}\n   */\n\n  var CanceledError_1 = CanceledError;\n  /**\n   * Refers to the AbortController class (native if available)\n   * @type {AbortController|AbortControllerEx}\n   */\n\n  var AbortController_1 = AbortController;\n  /**\n   * AbortControllerEx class\n   * @type {AbortControllerEx}\n   */\n\n  var AbortControllerEx_1 = AbortControllerEx;\n  /**\n   * Generic cancellation reason\n   */\n\n  var E_REASON_CANCELED_1 = E_REASON_CANCELED;\n  /**\n   * Cancellation reason for the case when the instance will be disposed\n   */\n\n  var E_REASON_DISPOSED_1 = E_REASON_DISPOSED;\n  /**\n   * Timeout cancellation reason\n   */\n\n  var E_REASON_TIMEOUT_1 = E_REASON_TIMEOUT;\n  /**\n   * React specific canceled reason\n   */\n\n  var E_REASON_UNMOUNTED_1 = E_REASON_UNMOUNTED;\n  /**\n   * async decorator\n   * @type {Function}\n   */\n\n  var async = CPromise$1.async;\n  /**\n   * listen decorator\n   * @type {Function}\n   */\n\n  var listen = CPromise$1.listen;\n  /**\n   * cancel decorator\n   * @type {Function}\n   */\n\n  var cancel = CPromise$1.cancel;\n  /**\n   * cancel decorator\n   * @type {Function}\n   */\n\n  var ReactComponent = CPromise$1.ReactComponent;\n  /**\n   * make CPromise function atomic\n   * @type {Function}\n   */\n\n  var atomic = CPromise$1.atomic;\n  /**\n   * append `done` chain to the resulting promise of the decorated method\n   * @type {Function}\n   */\n\n  var done = CPromise$1.done;\n  /**\n   * timeout decorator\n   * @type {Function}\n   */\n\n  var timeout = CPromise$1.timeout;\n  /**\n   * innerWeight decorator\n   * @type {Function}\n   */\n\n  var innerWeight = CPromise$1.innerWeight;\n  /**\n   * label decorator\n   * @type {Function}\n   */\n\n  var label = CPromise$1.label;\n  /**\n   * label decorator\n   * @type {Function}\n   */\n\n  var canceled = CPromise$1.canceled;\n  /**\n   * progress decorator\n   * @type {Function}\n   */\n\n  var progress = CPromise$1.progress;\n  /**\n   * @type {Function}\n   */\n\n  var promisify = CPromise$1.promisify;\n  var cPromise = {\n    CPromise: CPromise_1,\n    CanceledError: CanceledError_1,\n    AbortController: AbortController_1,\n    AbortControllerEx: AbortControllerEx_1,\n    E_REASON_CANCELED: E_REASON_CANCELED_1,\n    E_REASON_DISPOSED: E_REASON_DISPOSED_1,\n    E_REASON_TIMEOUT: E_REASON_TIMEOUT_1,\n    E_REASON_UNMOUNTED: E_REASON_UNMOUNTED_1,\n    async: async,\n    listen: listen,\n    cancel: cancel,\n    ReactComponent: ReactComponent,\n    atomic: atomic,\n    done: done,\n    timeout: timeout,\n    innerWeight: innerWeight,\n    label: label,\n    canceled: canceled,\n    progress: progress,\n    promisify: promisify\n  };\n  var CPromise = cPromise.CPromise;\n  var umdWrapper = CPromise;\n  return umdWrapper;\n});","map":null,"metadata":{},"sourceType":"script"}