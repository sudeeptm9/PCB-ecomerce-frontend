{"ast":null,"code":"/*\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\n*/\n\n/*jslint\n    white: true,\n    vars: true,\n    node: true\n*/\nfunction ObjectMergeOptions(opts) {\n  'use strict';\n\n  opts = opts || {};\n  this.depth = opts.depth || false; // circular ref check is true unless explicitly set to false\n  // ignore the jslint warning here, it's pointless.\n\n  this.throwOnCircularRef = 'throwOnCircularRef' in opts && opts.throwOnCircularRef === false ? false : true;\n}\n/*jslint unparam:true*/\n\n/**\n * Creates a new options object suitable for use with objectMerge.\n * @memberOf objectMerge\n * @param {Object} [opts] An object specifying the options.\n * @param {Object} [opts.depth = false] Specifies the depth to traverse objects\n *  during merging. If this is set to false then there will be no depth limit.\n * @param {Object} [opts.throwOnCircularRef = true] Set to false to suppress\n *  errors on circular references.\n * @returns {ObjectMergeOptions} Returns an instance of ObjectMergeOptions\n *  to be used with objectMerge.\n * @example\n *  var opts = objectMerge.createOptions({\n *      depth : 2,\n *      throwOnCircularRef : false\n *  });\n *  var obj1 = {\n *      a1 : {\n *          a2 : {\n *              a3 : {}\n *          }\n *      }\n *  };\n *  var obj2 = {\n *      a1 : {\n *          a2 : {\n *              a3 : 'will not be in output'\n *          },\n *          a22 : {}\n *      }\n *  };\n *  objectMerge(opts, obj1, obj2);\n */\n\n\nfunction createOptions(opts) {\n  'use strict';\n\n  var argz = Array.prototype.slice.call(arguments, 0);\n  argz.unshift(null);\n  var F = ObjectMergeOptions.bind.apply(ObjectMergeOptions, argz);\n  return new F();\n}\n/*jslint unparam:false*/\n\n/**\n * Merges JavaScript objects recursively without altering the objects merged.\n * @namespace Merges JavaScript objects recursively without altering the objects merged.\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\n * @param {ObjectMergeOptions} [opts] An options object created by \n *  objectMerge.createOptions. Options must be specified as the first argument\n *  and must be an object created with createOptions or else the object will\n *  not be recognized as an options object and will be merged instead.\n * @param {Object} shadows [[shadows]...] One or more objects to merge. Each\n *  argument given will be treated as an object to merge. Each object\n *  overwrites the previous objects descendant properties if the property name\n *  matches. If objects properties are objects they will be merged recursively\n *  as well.\n * @returns {Object} Returns a single merged object composed from clones of the\n *  input objects.\n * @example\n *  var objectMerge = require('object-merge');\n *  var x = {\n *      a : 'a',\n *      b : 'b',\n *      c : {\n *          d : 'd',\n *          e : 'e',\n *          f : {\n *              g : 'g'\n *          }\n *      }\n *  };\n *  var y = {\n *      a : '`a',\n *      b : '`b',\n *      c : {\n *          d : '`d'\n *      }\n *  };\n *  var z = {\n *      a : {\n *          b : '``b'\n *      },\n *      fun : function foo () {\n *          return 'foo';\n *      },\n *      aps : Array.prototype.slice\n *  };\n *  var out = objectMerge(x, y, z);\n *  // out.a will be {\n *  //         b : '``b'\n *  //     }\n *  // out.b will be '`b'\n *  // out.c will be {\n *  //         d : '`d',\n *  //         e : 'e',\n *  //         f : {\n *  //             g : 'g'\n *  //         }\n *  //     }\n *  // out.fun will be a clone of z.fun\n *  // out.aps will be equal to z.aps\n */\n\n\nfunction objectMerge(shadows) {\n  'use strict';\n\n  var objectForeach = require('object-foreach');\n\n  var cloneFunction = require('clone-function'); // this is the queue of visited objects / properties.\n\n\n  var visited = []; // various merge options\n\n  var options = {}; // gets the sequential trailing objects from array.\n\n  function getShadowObjects(shadows) {\n    var out = shadows.reduce(function (collector, shadow) {\n      if (shadow instanceof Object) {\n        collector.push(shadow);\n      } else {\n        collector = [];\n      }\n\n      return collector;\n    }, []);\n    return out;\n  } // gets either a new object of the proper type or the last primitive value\n\n\n  function getOutputObject(shadows) {\n    var out;\n    var lastShadow = shadows[shadows.length - 1];\n\n    if (lastShadow instanceof Array) {\n      out = [];\n    } else if (lastShadow instanceof Function) {\n      try {\n        out = cloneFunction(lastShadow);\n      } catch (e) {\n        throw new Error(e.message);\n      }\n    } else if (lastShadow instanceof Object) {\n      out = {};\n    } else {\n      // lastShadow is a primitive value;\n      out = lastShadow;\n    }\n\n    return out;\n  } // checks for circular references\n\n\n  function circularReferenceCheck(shadows) {\n    // if any of the current objects to process exist in the queue\n    // then throw an error.\n    shadows.forEach(function (item) {\n      if (item instanceof Object && visited.indexOf(item) > -1) {\n        throw new Error('Circular reference error');\n      }\n    }); // if none of the current objects were in the queue\n    // then add references to the queue.\n\n    visited = visited.concat(shadows);\n  }\n\n  function objectMergeRecursor(shadows, currentDepth) {\n    if (options.depth !== false) {\n      currentDepth = currentDepth ? currentDepth + 1 : 1;\n    } else {\n      currentDepth = 0;\n    }\n\n    if (options.throwOnCircularRef === true) {\n      circularReferenceCheck(shadows);\n    }\n\n    var out = getOutputObject(shadows);\n    /*jslint unparam: true */\n\n    function shadowHandler(val, prop, shadow) {\n      if (out[prop]) {\n        out[prop] = objectMergeRecursor([out[prop], shadow[prop]], currentDepth);\n      } else {\n        out[prop] = objectMergeRecursor([shadow[prop]], currentDepth);\n      }\n    }\n    /*jslint unparam:false */\n\n\n    function shadowMerger(shadow) {\n      objectForeach(shadow, shadowHandler);\n    } // short circuits case where output would be a primitive value\n    // anyway.\n\n\n    if (out instanceof Object && currentDepth <= options.depth) {\n      // only merges trailing objects since primitives would wipe out\n      // previous objects, as in merging {a:'a'}, 'a', and {b:'b'}\n      // would result in {b:'b'} so the first two arguments\n      // can be ignored completely.\n      var relevantShadows = getShadowObjects(shadows);\n      relevantShadows.forEach(shadowMerger);\n    }\n\n    return out;\n  } // determines whether an options object was passed in and\n  // uses it if present\n  // ignore the jslint warning here too.\n\n\n  if (arguments[0] instanceof ObjectMergeOptions) {\n    options = arguments[0];\n    shadows = Array.prototype.slice.call(arguments, 1);\n  } else {\n    options = createOptions();\n    shadows = Array.prototype.slice.call(arguments, 0);\n  }\n\n  return objectMergeRecursor(shadows);\n}\n\nobjectMerge.createOptions = createOptions;\nmodule.exports = objectMerge;","map":null,"metadata":{},"sourceType":"script"}