{"ast":null,"code":"var _defineProperty = require(\"F:\\\\Developments\\\\Web Devolopment\\\\pcbSudeep\\\\PCB-ecomerce-frontend-main\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"F:\\\\Developments\\\\Web Devolopment\\\\pcbSudeep\\\\PCB-ecomerce-frontend-main\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"F:\\\\Developments\\\\Web Devolopment\\\\pcbSudeep\\\\PCB-ecomerce-frontend-main\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _slicedToArray = require(\"F:\\\\Developments\\\\Web Devolopment\\\\pcbSudeep\\\\PCB-ecomerce-frontend-main\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _require = require(\"react\"),\n    useEffect = _require.useEffect,\n    useMemo = _require.useMemo,\n    useRef = _require.useRef,\n    useState = _require.useState;\n\nvar _require2 = require(\"c-promise2\"),\n    CPromise = _require2.CPromise,\n    CanceledError = _require2.CanceledError,\n    E_REASON_UNMOUNTED = _require2.E_REASON_UNMOUNTED;\n\nvar _require3 = require('is-equal-objects'),\n    isEqualObjects = _require3.isEqualObjects,\n    cloneObject = _require3.cloneObject;\n\nvar _CanceledError$regist = CanceledError.registerErrors({\n  E_REASON_QUEUE_OVERFLOW: 'overflow',\n  E_REASON_RESTART: 'restarted'\n}),\n    E_REASON_QUEUE_OVERFLOW = _CanceledError$regist.E_REASON_QUEUE_OVERFLOW,\n    E_REASON_RESTART = _CanceledError$regist.E_REASON_RESTART;\n\nfunction isGeneratorFn(thing) {\n  return typeof thing === 'function' && thing[Symbol.toStringTag] === 'GeneratorFunction';\n}\n\nvar isEvent = function isEvent(thing) {\n  return !!(thing && typeof thing === 'object' && thing.type);\n};\n\nvar removeElement = function removeElement(arr, element) {\n  var index = arr.indexOf(element);\n  return index !== -1 && arr.splice(index, 1);\n};\n/**\n * @typedef {function} CancelFn\n * @param {string} [reason]\n * returns {boolean}\n */\n\n/**\n * @typedef {function} UseAsyncEffectCancelFn\n * @param {string} [reason]\n * @property {Boolean} done\n * @property {*} result\n * @property {*} error\n * @property {boolean} canceled\n * @property {UseAsyncEffectCancelFn} cancel\n * @property {PauseFn} pause\n * @property {ResumeFn} resume\n * returns {boolean}\n */\n\n/**\n * @typedef {function} PauseFn\n * @param {*} [data]\n * returns {boolean}\n */\n\n/**\n * @typedef {function} ResumeFn\n * @param {*} [data]\n * returns {boolean}\n */\n\n/**\n * AsyncEffect hook to define cancellable effects\n * @param {GeneratorFunction} generatorFn\n * @param {object} [options]\n * @param {deps} [options.deps= []]\n * @param {boolean} [options.skipFirst= false]\n * @param {boolean} [options.states= false]\n * @param {boolean} [options.once= false]\n * @returns {UseAsyncEffectCancelFn}\n */\n\n\nvar useAsyncEffect = function useAsyncEffect(generatorFn, options) {\n  var _useRef = useRef({}),\n      current = _useRef.current;\n\n  var _ref = options && Array.isArray(options) ? {\n    deps: options\n  } : options || {},\n      _ref$deps = _ref.deps,\n      deps = _ref$deps === void 0 ? [] : _ref$deps,\n      _ref$skipFirst = _ref.skipFirst,\n      skipFirst = _ref$skipFirst === void 0 ? false : _ref$skipFirst,\n      _ref$states = _ref.states,\n      states = _ref$states === void 0 ? false : _ref$states,\n      _ref$once = _ref.once,\n      once = _ref$once === void 0 ? false : _ref$once;\n\n  var initialState = {\n    done: false,\n    result: undefined,\n    error: undefined,\n    canceled: false,\n    paused: false\n  };\n\n  var _ref2 = states ? useAsyncDeepState(initialState, {\n    watch: false\n  }) : [],\n      _ref3 = _slicedToArray(_ref2, 2),\n      state = _ref3[0],\n      setState = _ref3[1];\n\n  if (!isGeneratorFn(generatorFn)) {\n    throw TypeError('useAsyncEffect requires a generator as the first argument');\n  }\n\n  var cancel = useMemo(function () {\n    var cancel = function cancel(reason) {\n      var promise = current && current.promise;\n\n      if (promise) {\n        current.promise = null;\n        return promise.cancel(isEvent(reason) ? undefined : reason);\n      }\n\n      return false;\n    };\n\n    cancel.pause = function (data) {\n      return current.promise.pause(data);\n    };\n\n    cancel.resume = function (data) {\n      return current.promise.resume(data);\n    };\n\n    if (states) {\n      cancel[Symbol.iterator] = /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.delegateYield([cancel, state.done, state.result, state.error, state.canceled, state.paused], \"t0\", 1);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      });\n    } else {\n      cancel[Symbol.iterator] = function () {\n        throw Error(\"Can not unwrap states. The 'states' option is disabled\");\n      };\n    }\n\n    return cancel;\n  });\n  useEffect(function () {\n    if (!current.inited) {\n      current.inited = true;\n\n      if (skipFirst) {\n        return;\n      }\n    }\n\n    if (once && current.done) {\n      return;\n    }\n\n    var cb;\n    states && setState(initialState);\n    var promise = current.promise = CPromise.run(generatorFn, {\n      resolveSignatures: true,\n      scopeArg: true\n    }).then(function (result) {\n      current.done = true;\n\n      if (typeof result === 'function') {\n        cb = result;\n        states && setState({\n          done: true,\n          canceled: false\n        });\n        return;\n      }\n\n      states && setState({\n        done: true,\n        result: result,\n        canceled: false\n      });\n    }, function (err) {\n      if (!CanceledError.isCanceledError(err)) {\n        if (states) {\n          setState({\n            done: true,\n            error: err || new Error(err),\n            canceled: false\n          });\n        } else {\n          console.error(err);\n        }\n\n        return;\n      }\n\n      state && err.code !== E_REASON_UNMOUNTED && setState({\n        done: true,\n        error: err,\n        canceled: true\n      });\n    });\n\n    if (states) {\n      promise.onPause(function () {\n        setState({\n          paused: true\n        });\n      });\n      promise.onResume(function () {\n        setState({\n          paused: false\n        });\n      });\n    }\n\n    return function () {\n      cancel(E_REASON_UNMOUNTED);\n      cb && cb();\n    };\n  }, deps);\n\n  if (states) {\n    cancel.done = state.done;\n    cancel.result = state.result;\n    cancel.error = state.error;\n    cancel.canceled = state.canceled;\n    cancel.paused = state.paused;\n    cancel.cancel = cancel;\n  }\n\n  return cancel;\n};\n\nvar argsToPromiseMap = new Map();\n\nvar asyncEffectFactory = function asyncEffectFactory(options) {\n  if (options != null) {\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n\n    if (options.threads === undefined) {\n      options.threads = options.cancelPrevious || options.states ? 1 : 0;\n    } else {\n      if (!Number.isFinite(options.threads) || options.threads < 0) {\n        throw Error('threads must be a positive number');\n      }\n\n      if (options.states && options.threads !== 1) {\n        throw Error(\"Can not use states in not single threaded async function\");\n      }\n    }\n\n    if (options.queueSize !== undefined && (!Number.isFinite(options.queueSize) || options.queueSize < -1)) {\n      throw Error('queueSize must be a finite number >=-1');\n    }\n  }\n\n  var promises = [];\n  return {\n    promises: promises,\n    queue: [],\n    pending: 0,\n    args: null,\n    cancel: function cancel(reason) {\n      var _reason = isEvent(reason) ? undefined : reason;\n\n      promises.forEach(function (promise) {\n        return promise.cancel(_reason);\n      });\n      promises.length = 0;\n    },\n    pause: function pause(data) {\n      return promises.forEach(function (promise) {\n        return promise.pause(data);\n      });\n    },\n    resume: function resume(data) {\n      return promises.forEach(function (promise) {\n        return promise.resume(data);\n      });\n    },\n    initialState: {\n      done: false,\n      result: undefined,\n      error: undefined,\n      canceled: false,\n      pending: false\n    },\n    options: _objectSpread({\n      deps: [],\n      combine: false,\n      cancelPrevious: false,\n      threads: 0,\n      queueSize: -1,\n      scopeArg: false,\n      states: false,\n      catchErrors: false\n    }, Array.isArray(options) ? {\n      deps: options\n    } : options)\n  };\n};\n/**\n * @typedef {Function} UseAsyncCallbackDecoratedFn\n * @param {CPromise} [scope]\n * @param {*} [...userArgs]\n * @property {CancelFn} cancel\n * @property {PauseFn} pause\n * @property {ResumeFn} pause\n * @returns {*}\n */\n\n/**\n* @typedef {Function} UseAsyncCallbackDecoratedFn\n* @param {*} [...userArgs]\n* @property {CancelFn} cancel\n* @property {PauseFn} pause\n* @property {ResumeFn} pause\n* @returns {*}\n*/\n\n/**\n * useAsyncCallback hook for defining cancellable async routines\n * @param {GeneratorFunction} generatorFn\n * @param {object|array} [options]\n * @param {array} [options.deps= []]\n * @param {boolean} [options.combine= false]\n * @param {number} [options.threads=0]\n * @param {number} [options.queueSize=0]\n * @param {boolean} [options.cancelPrevious=false]\n * @param {boolean} [options.scopeArg= false]\n * @param {boolean} [options.states= true]\n * @param {boolean} [options.catchErrors= true]\n * @returns {UseAsyncCallbackDecoratedFn}\n */\n\n\nvar useAsyncCallback = function useAsyncCallback(generatorFn, options) {\n  var current = useFactory(asyncEffectFactory, [options]);\n  var initialState = current.initialState,\n      _current$options = current.options,\n      deps = _current$options.deps,\n      combine = _current$options.combine,\n      cancelPrevious = _current$options.cancelPrevious,\n      threads = _current$options.threads,\n      queueSize = _current$options.queueSize,\n      scopeArg = _current$options.scopeArg,\n      states = _current$options.states,\n      catchErrors = _current$options.catchErrors;\n\n  var _ref4 = states ? useAsyncDeepState(initialState, {\n    watch: false\n  }) : [],\n      _ref5 = _slicedToArray(_ref4, 2),\n      state = _ref5[0],\n      setState = _ref5[1];\n\n  var callback = useMemo(function () {\n    var promises = current.promises,\n        queue = current.queue,\n        cancel = current.cancel,\n        pause = current.pause,\n        resume = current.resume;\n\n    var fn = function fn() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var n;\n\n      if (combine && (n = promises.length)) {\n        var _promise;\n\n        while (n-- > 0) {\n          _promise = promises[n];\n\n          if (argsToPromiseMap.has(_promise) && isEqualObjects(argsToPromiseMap.get(_promise), args)) {\n            if (cancelPrevious) {\n              _promise.cancel(E_REASON_RESTART);\n\n              break;\n            }\n\n            return CPromise.resolve(_promise);\n          }\n        }\n      }\n\n      var resolveGenerator = function resolveGenerator() {\n        return CPromise.run(generatorFn, {\n          args: args,\n          resolveSignatures: true,\n          scopeArg: scopeArg\n        });\n      };\n\n      cancelPrevious && !combine && cancel(E_REASON_RESTART);\n\n      if (threads || queueSize !== -1) {\n        var started;\n\n        var _promise2 = new CPromise(function (resolve) {\n          var start = function start() {\n            current.pending++;\n            started = true;\n\n            if (states) {\n              setState(_objectSpread(_objectSpread({}, initialState), {}, {\n                pending: true\n              }));\n            }\n\n            resolve();\n          };\n\n          if (current.pending === threads) {\n            if (queueSize !== -1 && queue.length === queueSize) {\n              throw CanceledError.from(E_REASON_QUEUE_OVERFLOW);\n            }\n\n            return queue.push(start);\n          }\n\n          start();\n        }).weight(0).then(resolveGenerator)[catchErrors ? 'done' : 'finally'](function (value, isRejected) {\n          started && current.pending--;\n          removeElement(promises, _promise2);\n          combine && argsToPromiseMap.delete(_promise2);\n          queue.length && queue.shift()();\n          var canceled = !!(isRejected && CanceledError.isCanceledError(value));\n\n          if (canceled && (value.code === E_REASON_UNMOUNTED || value.code === E_REASON_RESTART)) {\n            return;\n          }\n\n          states && setState({\n            pending: false,\n            done: true,\n            error: isRejected ? value : undefined,\n            result: isRejected ? undefined : value,\n            canceled: canceled\n          });\n          return isRejected ? undefined : value;\n        }).weight(0).aggregate();\n\n        if (states) {\n          _promise2.onPause(function () {\n            return setState({\n              paused: true\n            });\n          });\n\n          _promise2.onResume(function () {\n            return setState({\n              paused: false\n            });\n          });\n        }\n\n        promises.push(_promise2);\n        combine && argsToPromiseMap.set(_promise2, args);\n        return _promise2;\n      }\n\n      cancelPrevious && cancel(E_REASON_RESTART);\n      var promise = resolveGenerator()[catchErrors ? 'done' : 'finally'](function () {\n        removeElement(promises, promise);\n        combine && argsToPromiseMap.delete(promise);\n      }).weight(0).aggregate();\n      promises.push(promise);\n\n      if (combine) {\n        argsToPromiseMap.set(promise, args);\n      }\n\n      return promise;\n    };\n\n    if (states) {\n      var makeDescriptor = function makeDescriptor(name) {\n        return {\n          get: function get() {\n            return state[name];\n          }\n        };\n      };\n\n      Object.defineProperties(fn, _defineProperty({\n        done: makeDescriptor('done'),\n        pending: makeDescriptor('pending'),\n        result: makeDescriptor('result'),\n        error: makeDescriptor('error'),\n        canceled: makeDescriptor('canceled'),\n        paused: makeDescriptor('paused')\n      }, Symbol.iterator, {\n        value: /*#__PURE__*/_regeneratorRuntime.mark(function value() {\n          return _regeneratorRuntime.wrap(function value$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  return _context2.delegateYield([fn, cancel, state.pending, state.done, state.result, state.error, state.canceled, state.paused], \"t0\", 1);\n\n                case 1:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, value);\n        })\n      }));\n    } else {\n      fn[Symbol.iterator] = /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.delegateYield([fn, cancel], \"t0\", 1);\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2);\n      });\n    }\n\n    fn.cancel = cancel;\n    fn.pause = pause;\n    fn.resume = resume;\n    return fn;\n  }, deps);\n  useEffect(function () {\n    return function () {\n      return callback.cancel(E_REASON_UNMOUNTED);\n    };\n  }, []);\n  return callback;\n};\n\nvar initialized = new WeakSet();\n\nvar useFactory = function useFactory(factory, args) {\n  var _useRef2 = useRef({}),\n      current = _useRef2.current;\n\n  if (initialized.has(current)) return current;\n  initialized.add(current);\n  return Object.assign(current, factory.apply(null, args));\n};\n\nvar assignEnumerableProps = function assignEnumerableProps(source, target) {\n  Object.assign(source, target);\n  var symbols = Object.getOwnPropertySymbols(target);\n  var i = symbols.length;\n\n  while (i-- > 0) {\n    var symbol = symbols[i];\n    source[symbol] = target[symbol];\n  }\n\n  return source;\n};\n\nvar protoState = Object.create(null, _defineProperty({\n  toJSON: {\n    value: function toJSON() {\n      var obj = {};\n      var target = this;\n\n      do {\n        assignEnumerableProps(obj, target);\n      } while ((target = Object.getPrototypeOf(target)) && target !== Object.prototype);\n\n      return obj;\n    }\n  }\n}, isEqualObjects.plainObject, {\n  value: true\n}));\n\nvar getAllKeys = function getAllKeys(obj) {\n  return Object.keys(obj).concat(Object.getOwnPropertyNames(obj));\n};\n/**\n * useAsyncDeepState hook whose setter returns a promise\n * @param {*} [initialState]\n * @param {Boolean} [watch= true]\n * @param {Boolean} [defineSetters= true]\n * @returns {[any, function(*=, boolean=): (Promise<*>|undefined)]}\n */\n\n\nvar useAsyncDeepState = function useAsyncDeepState(initialState) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref6$watch = _ref6.watch,\n      watch = _ref6$watch === void 0 ? true : _ref6$watch,\n      _ref6$defineSetters = _ref6.defineSetters,\n      defineSetters = _ref6$defineSetters === void 0 ? true : _ref6$defineSetters;\n\n  var current = useFactory(function () {\n    if (initialState !== undefined && typeof initialState !== \"object\") {\n      throw TypeError('initial state must be a plain object');\n    }\n\n    var setter = function setter(patch, scope, cb) {\n      setState(function (state) {\n        if (typeof patch === 'function') {\n          patch = patch(state);\n        }\n\n        if (patch !== true && patch != null && typeof patch !== 'object') {\n          throw new TypeError('patch must be a plain object or boolean');\n        }\n\n        if (patch !== true && (patch === null || assignEnumerableProps(current.state, patch)) && !current.stateChanged && isEqualObjects(current.state, current.snapshot)) {\n          scope && cb(state);\n          return state;\n        }\n\n        current.stateChanged = true;\n\n        if (scope) {\n          current.callbacks.set(scope, cb);\n          scope.onDone(function () {\n            return current.callbacks.delete(scope);\n          });\n        }\n\n        return Object.freeze(Object.create(current.proxy));\n      });\n    };\n\n    var state = assignEnumerableProps(Object.create(protoState), initialState);\n    var proxy = Object.create(state, defineSetters && getAllKeys(initialState).reduce(function (props, prop) {\n      props[prop] = {\n        get: function get() {\n          return state[prop];\n        },\n        set: function set(value) {\n          state[prop] = value;\n          setter(null);\n        }\n      };\n      return props;\n    }, {}));\n    return {\n      state: state,\n      snapshot: null,\n      proxy: proxy,\n      initialState: Object.freeze(Object.create(proxy)),\n      stateChanged: false,\n      callbacks: new Map(),\n      setter: setter\n    };\n  });\n\n  var _useState = useState(current.initialState),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  useEffect(function () {\n    current.stateChanged = false;\n    current.callbacks.forEach(function (cb) {\n      return cb(state);\n    });\n    current.callbacks.clear();\n    current.snapshot = cloneObject(current.state);\n  }, [state]);\n  return [state,\n  /**\n   * state async accessor\n   * @param {Object} [handlerOrPatch]\n   * @param {Boolean} [watchChanges= true]\n   * @returns {Promise<*>|undefined}\n   */\n  function (handlerOrPatch) {\n    var watchChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : watch;\n    return watchChanges ? new CPromise(function (resolve, reject, scope) {\n      current.setter(handlerOrPatch, scope, resolve);\n    }) : current.setter(handlerOrPatch);\n  }];\n};\n\nvar useAsyncWatcher = function useAsyncWatcher() {\n  for (var _len2 = arguments.length, value = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    value[_key2] = arguments[_key2];\n  }\n\n  var ref = useRef({\n    oldValue: value\n  });\n\n  if (!ref.current.callbacks) {\n    ref.current.callbacks = new Map();\n  }\n\n  var multiple = value.length > 1;\n  useEffect(function () {\n    var current = ref.current;\n    var data = multiple ? value.map(function (value, index) {\n      return [value, current.oldValue[index]];\n    }) : [value[0], current.oldValue[0]];\n    current.callbacks.forEach(function (cb) {\n      return cb(data);\n    });\n    current.callbacks.clear();\n    current.oldValue = value;\n  }, value);\n  /**\n   * @param {Boolean} [grabPrevValue]\n   * @returns {Promise}\n   */\n\n  return function (grabPrevValue) {\n    return new CPromise(function (resolve, reject, scope) {\n      ref.current.callbacks.set(scope, function (entry) {\n        if (multiple) {\n          resolve(grabPrevValue ? entry : entry.map(function (values) {\n            return values[0];\n          }));\n        }\n\n        resolve(grabPrevValue ? entry : entry[0]);\n      });\n      scope.onDone(function () {\n        ref.current.callbacks.delete(scope);\n      });\n    });\n  };\n};\n\nmodule.exports = {\n  useAsyncEffect: useAsyncEffect,\n  useAsyncCallback: useAsyncCallback,\n  useAsyncDeepState: useAsyncDeepState,\n  useAsyncWatcher: useAsyncWatcher,\n  CanceledError: CanceledError,\n  E_REASON_UNMOUNTED: E_REASON_UNMOUNTED,\n  E_REASON_RESTART: E_REASON_RESTART,\n  E_REASON_QUEUE_OVERFLOW: E_REASON_QUEUE_OVERFLOW\n};","map":null,"metadata":{},"sourceType":"script"}